<!doctypehtml><html class="sidebar-visible no-js light"lang=en><head><meta charset=UTF-8><title>BRE/ERE Regular Expressions - CLI text processing with GNU grep and ripgrep</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta content="Example based guide to mastering GNU grep and ripgrep"name=description><meta content=width=device-width,initial-scale=1 name=viewport><meta content=#ffffff name=theme-color><meta content="CLI text processing with GNU grep and ripgrep"property=og:title><meta content=website property=og:type><meta content="Example based guide to mastering GNU grep and ripgrep"property=og:description><meta content=https://learnbyexample.github.io/learn_gnugrep_ripgrep/ property=og:url><meta content=https://raw.githubusercontent.com/learnbyexample/learn_gnugrep_ripgrep/master/images/grep_ls.png property=og:image><meta content=1280 property=og:image:width><meta content=720 property=og:image:height><meta content=summary_large_image property=twitter:card><meta content=@learn_byexample property=twitter:site><link href=favicon.svg rel=icon><link rel="shortcut icon"href=favicon.png><link href=css/variables.css rel=stylesheet><link href=css/general.css rel=stylesheet><link href=css/chrome.css rel=stylesheet><link href=FontAwesome/css/font-awesome.css rel=stylesheet><link href=fonts/fonts.css rel=stylesheet><link href=highlight.css rel=stylesheet><link href=tomorrow-night.css rel=stylesheet><link href=ayu-highlight.css rel=stylesheet><link href=style.css rel=stylesheet><body><script>var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";</script><script>try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }</script><script>var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');</script><script>var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);</script><nav aria-label="Table of contents"class=sidebar id=sidebar><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=cover.html>Cover</a><li class="chapter-item expanded affix"><a href=buy.html>Buy PDF/EPUB versions</a><li class="chapter-item expanded"><a href=preface.html><strong aria-hidden=true>1.</strong> Preface</a><li class="chapter-item expanded"><a href=introduction.html><strong aria-hidden=true>2.</strong> Introduction</a><li class="chapter-item expanded"><a href=frequently-used-options.html><strong aria-hidden=true>3.</strong> Frequently used options</a><li class="chapter-item expanded"><a class=active href=breere-regular-expressions.html><strong aria-hidden=true>4.</strong> BRE/ERE Regular Expressions</a><li class="chapter-item expanded"><a href=context-matching.html><strong aria-hidden=true>5.</strong> Context matching</a><li class="chapter-item expanded"><a href=recursive-search.html><strong aria-hidden=true>6.</strong> Recursive search</a><li class="chapter-item expanded"><a href=miscellaneous-options.html><strong aria-hidden=true>7.</strong> Miscellaneous options</a><li class="chapter-item expanded"><a href=perl-compatible-regular-expressions.html><strong aria-hidden=true>8.</strong> Perl Compatible Regular Expressions</a><li class="chapter-item expanded"><a href=gotchas-and-tricks.html><strong aria-hidden=true>9.</strong> Gotchas and Tricks</a><li class="chapter-item expanded"><a href=ripgrep.html><strong aria-hidden=true>10.</strong> ripgrep</a><li class="chapter-item expanded"><a href=further-reading.html><strong aria-hidden=true>11.</strong> Further Reading</a><li class="chapter-item expanded"><a href=Exercise_solutions.html><strong aria-hidden=true>12.</strong> Exercise Solutions</a></li><br><hr><li class="chapter-item expanded"><i class="fa fa-github"id=git-repository-button></i><a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep>   Source code</a><li class="chapter-item expanded"><i class="fa fa-home"id=home-button></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i class="fa fa-book"id=book-button></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i class="fa fa-envelope"id=mail-button></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a><li class="chapter-item expanded"><i class="fa fa-twitter"id=twitter-button></i><a href=https://twitter.com/learn_byexample>   Twitter</a></ol></div><div class=sidebar-resize-handle id=sidebar-resize-handle></div></nav><div class=page-wrapper id=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div class="menu-bar sticky bordered"id=menu-bar><div class=left-buttons><button aria-label="Toggle Table of Contents"title="Toggle Table of Contents"aria-controls=sidebar class=icon-button id=sidebar-toggle type=button><i class="fa fa-bars"></i></button><button aria-label="Change theme"title="Change theme"aria-controls=theme-list aria-expanded=false aria-haspopup=true class=icon-button id=theme-toggle type=button><i class="fa fa-paint-brush"></i></button><ul aria-label=Themes class=theme-popup id=theme-list role=menu><li role=none><button class=theme id=light role=menuitem>Light (default)</button><li role=none><button class=theme id=rust role=menuitem>Rust</button><li role=none><button class=theme id=coal role=menuitem>Coal</button><li role=none><button class=theme id=navy role=menuitem>Navy</button><li role=none><button class=theme id=ayu role=menuitem>Ayu</button></ul><button aria-label="Toggle Searchbar"title="Search. (Shortkey: s)"aria-controls=searchbar aria-expanded=false aria-keyshortcuts=S class=icon-button id=search-toggle type=button><i class="fa fa-search"></i></button></div><h1 class=menu-title>CLI text processing with GNU grep and ripgrep</h1><div class=right-buttons><a aria-label=Blog href=https://learnbyexample.github.io title=Blog> <i class="fa fa-home"id=home-button></i> </a><a aria-label=Twitter href=https://twitter.com/learn_byexample title=Twitter> <i class="fa fa-twitter"id=twitter-button></i> </a><a aria-label="Git repository"title="Git repository"href=https://github.com/learnbyexample/learn_gnugrep_ripgrep> <i class="fa fa-github"id=git-repository-button></i> </a></div></div><div class=hidden id=search-wrapper><form class=searchbar-outer id=searchbar-outer><input placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header id=searchbar name=searchbar type=search></form><div class="searchresults-outer hidden"id=searchresults-outer><div class=searchresults-header id=searchresults-header></div><ul id=searchresults></ul></div></div><script>document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });</script><div class=content id=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=breere-regular-expressions><a class=header href=#breere-regular-expressions>BRE/ERE Regular Expressions</a></h1><p>This chapter covers Basic and Extended Regular Expressions as implemented in <code>GNU grep</code>. Unless otherwise indicated, examples and descriptions will assume ASCII input. <code>GNU grep</code> also supports Perl Compatible Regular Expressions, which will be discussed in a <a href=./perl-compatible-regular-expressions.html#perl-compatible-regular-expressions>later chapter</a>.<p>By default, <code>grep</code> treats the search pattern as Basic Regular Expression (BRE). Here are the various options available to choose a particular flavor:<ul><li><code>-G</code> option can be used to specify explicitly that BRE is needed<li><code>-E</code> option will enable Extended Regular Expression (ERE) <ul><li>in <code>GNU grep</code>, BRE and ERE only differ in how metacharacters are specified, no difference in features</ul><li><code>-F</code> option will cause the search patterns to be treated literally<li><code>-P</code> if available, this option will enable Perl Compatible Regular Expression (PCRE)</ul><blockquote><p><img alt=info src=images/info.svg> The <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep/tree/master/example_files>example_files</a> directory has all the files used in the examples.</blockquote><blockquote><p><img alt=info src=./images/info.svg> See <a href=https://www.gnu.org/software/grep/manual/grep.html#Problematic-Regular-Expressions>grep manual: Problematic Regular Expressions</a> if you are working on portable scripts. See also <a href=https://pubs.opengroup.org/onlinepubs/9799919799/basedefs/V1_chap09.html>POSIX specification for BRE and ERE</a>.</blockquote><h2 id=line-anchors><a class=header href=#line-anchors>Line Anchors</a></h2><p>Instead of matching anywhere in the line, restrictions can be specified. For now, you'll see the ones that are already part of BRE/ERE. In later sections and chapters, you'll get to know how to define your own rules for restriction. These restrictions are made possible by assigning special meaning to certain characters and escape sequences.<p>The characters with special meaning are known as <strong>metacharacters</strong> in regular expressions parlance. In case you need to match those characters literally, you need to escape them with a <code>\</code> (discussed in the <a href=./breere-regular-expressions.html#escaping-metacharacters>Escaping metacharacters</a> section).<p>There are two line anchors:<ul><li><code>^</code> metacharacter restricts the matching to the start of the line<li><code>$</code> metacharacter restricts the matching to the end of the line</ul><p>Here are some examples:<pre><code class=language-bash>$ cat anchors.txt
sub par
spar
apparent effort
two spare computers
cart part tart mart

# lines starting with 's'
$ grep '^s' anchors.txt
sub par
spar

# lines ending with 'rt'
$ grep 'rt$' anchors.txt
apparent effort
cart part tart mart
</code></pre><p>You can combine these two anchors to match only whole lines. Or, use the <code>-x</code> option.<pre><code class=language-bash>$ printf 'spared no one\npar\nspar\ndare' | grep '^par$'
par
$ printf 'spared no one\npar\nspar\ndare' | grep -x 'par'
par
</code></pre><h2 id=word-anchors><a class=header href=#word-anchors>Word Anchors</a></h2><p>The second type of restriction is word anchors. A word character is any alphabet (irrespective of case), digit and the underscore character. This is similar to using <code>-w</code> option, with added flexibility of using word anchor only at the start or end of a word.<p>The escape sequence <code>\b</code> denotes a word boundary. This works for both the start of word and the end of word anchoring. Start of word means either the character prior to the word is a non-word character or there is no character (start of line). Similarly, end of word means the character after the word is a non-word character or no character (end of line). This implies that you cannot have word boundaries without a word character. Here are some examples:<pre><code class=language-bash>$ cat anchors.txt
sub par
spar
apparent effort
two spare computers
cart part tart mart

# match words starting with 'par'
$ grep '\bpar' anchors.txt
sub par
cart part tart mart

# match words ending with 'par'
$ grep 'par\b' anchors.txt
sub par
spar

# match only the whole word 'par'
$ grep '\bpar\b' anchors.txt
sub par
$ grep -w 'par' anchors.txt
sub par
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> Word boundaries behave a bit differently than the <code>-w</code> option. See the <a href=./gotchas-and-tricks.html#word-boundary-differences>Word boundary differences</a> section for details.</blockquote><blockquote><p><img alt=info src=images/info.svg> Alternatively, you can use <code>\<</code> to indicate the start of word anchor and <code>\></code> to indicate the end of word anchor. Using <code>\b</code> is preferred as it is more commonly used in other regular expression implementations and has <code>\B</code> as its opposite.</blockquote><h2 id=opposite-word-anchor><a class=header href=#opposite-word-anchor>Opposite Word Anchor</a></h2><p>The word boundary has an opposite anchor too. <code>\B</code> matches wherever <code>\b</code> doesn't match. This duality will be seen with some other escape sequences too.<pre><code class=language-bash># match 'par' if it is surrounded by word characters
$ grep '\Bpar\B' anchors.txt
apparent effort
two spare computers

# match 'par' but not as the start of word
$ grep '\Bpar' anchors.txt
spar
apparent effort
two spare computers

# match 'par' but not as the end of word
$ grep 'par\B' anchors.txt
apparent effort
two spare computers
cart part tart mart
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> Negative logic is handy in many text processing situations. But use it with care, you might end up matching things you didn't intend.</blockquote><h2 id=alternation><a class=header href=#alternation>Alternation</a></h2><p>Many a times, you'd want to search for multiple terms. In a conditional expression, you can use the logical operators to combine multiple conditions. With regular expressions, the <code>|</code> metacharacter is similar to logical OR. The regular expression will match if any of the patterns separated by <code>|</code> is satisfied.<p>Alternation is similar to using multiple <code>-e</code> option, but provides more flexibility when combined with grouping. The <code>|</code> metacharacter syntax varies between BRE and ERE. Quoting from the manual:<blockquote><p>In basic regular expressions the meta-characters <code>?</code>, <code>+</code>, <code>{</code>, <code>|</code>, <code>(</code>, and <code>)</code> lose their special meaning; instead use the backslashed versions <code>\?</code>, <code>\+</code>, <code>\{</code>, <code>\|</code>, <code>\(</code>, and <code>\)</code>.</blockquote><p>Here are some examples:<pre><code class=language-bash>$ cat pets.txt
I like cats
I like parrots
I like dogs

# three different ways to match either 'cat' or 'dog'
$ grep 'cat\|dog' pets.txt
I like cats
I like dogs
$ grep -E 'cat|dog' pets.txt
I like cats
I like dogs
$ grep -e 'cat' -e 'dog' pets.txt
I like cats
I like dogs

# extract either 'cat' or 'dog' or 'fox' case insensitively
$ printf 'CATs dog bee parrot FoX' | grep -ioE 'cat|dog|fox'
CAT
dog
FoX
</code></pre><p>Here's an example of alternate patterns with their own anchors:<pre><code class=language-bash># match lines starting with 't' or a line containing a word ending with 'ar'
$ grep -E '^t|ar\b' anchors.txt
sub par
spar
two spare computers
</code></pre><p>Sometimes, you want to view the entire input file with only the required search patterns highlighted. You can use an empty alternation to match any line.<p align=center><img alt="highlighting patterns in whole input"src=./images/highlight_patterns.png><h2 id=alternation-precedence><a class=header href=#alternation-precedence>Alternation precedence</a></h2><p>There are some tricky corner cases when using alternation. If it is used for filtering a line, there is no ambiguity. However, for matching portion extraction with <code>-o</code> option, it depends on a few factors. Say, you want to extract <code>are</code> or <code>spared</code> — which one should get precedence? The bigger word <code>spared</code> or the substring <code>are</code> inside it or based on something else?<p>The alternative which matches earliest in the input gets precedence.<pre><code class=language-bash>$ echo 'car spared spar' | grep -oE 'are|spared'
spared
$ echo 'car spared spar' | grep -oE 'spared|are'
spared
</code></pre><p>In case of matches starting from same location, for example <code>party</code> and <code>par</code>, the longest matching portion gets precedence. See the <a href=./breere-regular-expressions.html#longest-match-wins>Longest match wins</a> section for more examples. See <a href=https://www.regular-expressions.info/alternation.html>regular-expressions: alternation</a> for more information on this topic.<pre><code class=language-bash># same output irrespective of alternation order
$ echo 'pool party 2' | grep -oE 'party|par'
party
$ echo 'pool party 2' | grep -oE 'par|party'
party

# other implementations like PCRE have left-to-right priority
$ echo 'pool party 2' | grep -oP 'par|party'
par
</code></pre><h2 id=grouping><a class=header href=#grouping>Grouping</a></h2><p>Often, there are some common things among the regular expression alternatives. It could be common characters or qualifiers like the anchors. In such cases, you can group them using a pair of parentheses metacharacters. Similar to <code>a(b+c)d = abd+acd</code> in maths, you get <code>a(b|c)d = abd|acd</code> in regular expressions.<pre><code class=language-bash># without grouping
$ printf 'red\nreform\nread\ncrest' | grep -E 'reform|rest'
reform
crest
# with grouping
$ printf 'red\nreform\nread\ncrest' | grep -E 're(form|st)'
reform
crest

# without grouping
$ grep -E '\bpar\b|\bpart\b' anchors.txt
sub par
cart part tart mart
# taking out common anchors
$ grep -E '\b(par|part)\b' anchors.txt
sub par
cart part tart mart
# taking out common characters as well
# you'll later learn a better technique instead of using an empty alternate
$ grep -E '\bpar(|t)\b' anchors.txt
sub par
cart part tart mart
</code></pre><h2 id=escaping-metacharacters><a class=header href=#escaping-metacharacters>Escaping metacharacters</a></h2><p>You have already seen a few metacharacters and escape sequences that help compose a regular expression. To match the metacharacters literally, i.e. to remove their special meaning, prefix those characters with a <code>\</code> character. To indicate a literal <code>\</code> character, use <code>\\</code>. Some of the metacharacters, like the line anchors, lose their special meaning when not used in their customary positions with BRE syntax.<p>If there are many metacharacters to be escaped, try to work out alternate solutions by using <code>-F</code> (paired with regular expression like options such as <code>-e</code>, <code>-f</code>, <code>-i</code>, <code>-w</code>, <code>-x</code>, etc) or by switching between ERE and BRE. Another option is to use PCRE (covered later), which has special constructs to mark whole or portion of pattern to be matched literally — especially useful when using shell variables.<pre><code class=language-bash># line anchors aren't special away from customary positions with BRE
$ echo 'a^2 + b^2 - C*3' | grep 'b^2'
a^2 + b^2 - C*3
$ echo '$a = $b + $c' | grep '$b'
$a = $b + $c

# escape line anchors to match literally if you are using ERE
# or if you want to match them at customary positions with BRE
$ echo '$a = $b + $c' | grep -o '\$' | wc -l
3

# or use -F where possible
$ echo '$a = $b + $c' | grep -oF '$' | wc -l
3
</code></pre><p>Here's another example to show differences between BRE and ERE:<pre><code class=language-bash># cannot use -F here as line anchor is needed
$ printf '(a/b) + c\n3 + (a/b) - c' | grep '^(a/b)'
(a/b) + c
$ printf '(a/b) + c\n3 + (a/b) - c' | grep -E '^\(a/b)'
(a/b) + c
</code></pre><h2 id=matching-characters-like-tabs><a class=header href=#matching-characters-like-tabs>Matching characters like tabs</a></h2><p><code>GNU grep</code> doesn't support escape sequences like <code>\t</code> (tab) and <code>\n</code> (newline). Neither does it support formats like <code>\xNN</code> (specifying a character by its codepoint value in hexadecimal format). Shells like Bash support <a href=https://www.gnu.org/software/bash/manual/bash.html#ANSI_002dC-Quoting>ANSI-C Quoting</a> as an alternate way to use such escape sequences.<pre><code class=language-bash># $'..' is ANSI-C quoting syntax
$ printf 'go\tto\ngo to' | grep $'go\tto'
go      to

# \x20 in hexadecimal represents the space character
$ printf 'go\tto\ngo to' | grep $'go\x20to'
go to
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> Undefined escape sequences are treated as the character it escapes. Newer versions of <code>GNU grep</code> will generate a warning for such escapes and might become errors in future versions.<pre><code class=language-bash>$ echo 'sea eat car rat eel tea' | grep 's\ea'
grep: warning: stray \ before e
sea eat car rat eel tea
</code></pre></blockquote><h2 id=the-dot-metacharacter><a class=header href=#the-dot-metacharacter>The dot metacharacter</a></h2><p>The dot metacharacter serves as a placeholder to match any character. Later you'll learn how to define your own custom placeholders for a limited set of characters.<pre><code class=language-bash># extract 'c', followed by any character and then 't'
$ echo 'tac tin cot abc:tuv excite' | grep -o 'c.t'
c t
cot
c:t
cit

$ printf '42\t33\n'
42      33
# extract '2', followed by any character and then '3'
$ printf '42\t33\n' | grep -o '2.3'
2       3
</code></pre><p>If you are using a Unix-like distribution, you'll likely have the <code>/usr/share/dict/words</code> dictionary file. This will be used as an input file to illustrate regular expression examples in this chapter. This file is included in the <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep/blob/master/example_files/words.txt>learn_gnugrep_ripgrep repo</a> as <code>words.txt</code> file (modified to make it ASCII only).<pre><code class=language-bash>$ wc -l words.txt
98927 words.txt

# 5 character lines starting with 'du' and ending with 'ts' or 'ky'
$ grep -xE 'du.(ky|ts)' words.txt
ducts
duets
dusky
dusts
</code></pre><h2 id=quantifiers><a class=header href=#quantifiers>Quantifiers</a></h2><p>Alternation helps you match one among multiple patterns. Combining the dot metacharacter with quantifiers (and alternation if needed) paves a way to perform logical AND between patterns. For example, to check if a string matches two patterns with any number of characters in between. Quantifiers can be applied to characters, groupings and some more constructs that'll be discussed later. Apart from the ability to specify exact quantity and bounded range, these can also match unbounded varying quantities.<p>BRE/ERE support only one type of quantifiers, whereas PCRE supports three types. Quantifiers in <code>GNU grep</code> behave mostly like greedy quantifiers supported by PCRE, but there are subtle differences, which will be discussed with examples later on.<p>First up, the <code>?</code> metacharacter which quantifies a character or group to match <code>0</code> or <code>1</code> times. This helps to define optional patterns and build terser patterns compared to alternation and groupings for some cases.<pre><code class=language-bash># same as: grep -E '\b(fe.d|fed)\b'
# BRE version: grep -w 'fe.\?d'
$ printf 'fed\nfod\nfe:d\nfeed' | grep -wE 'fe.?d'
fed
fe:d
feed

# same as: grep -E '\bpar(|t)\b'
$ printf 'sub par\nspare\npart time' | grep -wE 'part?'
sub par
part time

# same as: grep -oE 'part|parrot'
$ echo 'par part parrot parent' | grep -oE 'par(ro)?t'
part
parrot
# same as: grep -oE 'part|parrot|parent'
$ echo 'par part parrot parent' | grep -oE 'par(en|ro)?t'
part
parrot
parent
</code></pre><p>The <code>*</code> metacharacter quantifies a character or group to match <code>0</code> or more times.<pre><code class=language-bash># extract 'f' followed by zero or more of 'e' followed by 'd'
$ echo 'fd fed fod fe:d feeeeder' | grep -o 'fe*d'
fd
fed
feeeed

# extract zero or more of '1' followed by '2'
$ echo '3111111111125111142' | grep -o '1*2'
11111111112
2
</code></pre><p>The <code>+</code> metacharacter quantifies a character or group to match <code>1</code> or more times.<pre><code class=language-bash># extract 'f' followed by one or more of 'e' followed by 'd'
# BRE version: grep -o 'fe\+d'
$ echo 'fd fed fod fe:d feeeeder' | grep -oE 'fe+d'
fed
feeeed

# extract 'f' followed by at least one of 'e' or 'o' or ':' followed by 'd'
$ echo 'fd fed fod fe:d feeeeder' | grep -oE 'f(e|o|:)+d'
fed
fod
fe:d
feeeed

# extract one or more of '1' followed by '2'
$ echo '3111111111125111142' | grep -oE '1+2'
11111111112
# extract one or more of '1' followed by optional '4' and then '2'
$ echo '3111111111125111142' | grep -oE '1+4?2'
11111111112
111142
</code></pre><p>You can specify a range of integer numbers, both bounded and unbounded, using <code>{}</code> metacharacters. There are four ways to use this quantifier as listed below:<div class=table-wrapper><table><thead><tr><th>Quantifier<th>Description<tbody><tr><td><code>{m,n}</code><td>match <code>m</code> to <code>n</code> times<tr><td><code>{m,}</code><td>match at least <code>m</code> times<tr><td><code>{,n}</code><td>match up to <code>n</code> times (including <code>0</code> times)<tr><td><code>{n}</code><td>match exactly <code>n</code> times</table></div><pre><code class=language-bash># note that stray characters like space is not allowed anywhere within {}
# BRE version: grep -o 'ab\{1,4\}c'
$ echo 'abc ac adc abbc xabbbcz bbb bc abbbbbc' | grep -oE 'ab{1,4}c'
abc
abbc
abbbc

$ echo 'abc ac adc abbc xabbbcz bbb bc abbbbbc' | grep -oE 'ab{3,}c'
abbbc
abbbbbc

$ echo 'abc ac adc abbc xabbbcz bbb bc abbbbbc' | grep -oE 'ab{,2}c'
abc
ac
abbc

$ echo 'abc ac adc abbc xabbbcz bbb bc abbbbbc' | grep -oE 'ab{3}c'
abbbc
</code></pre><blockquote><p><img alt=info src=images/info.svg> To match <code>{}</code> metacharacters literally (assuming ERE), escaping <code>{</code> alone is enough. Or if it doesn't conform strictly to any of the four forms listed above, escaping is not needed at all.<pre><code class=language-bash>$ echo 'a{5} = 10' | grep -E 'a\{5}'
a{5} = 10

$ echo 'report_{a,b}.txt' | grep -E '_{a,b}'
report_{a,b}.txt
</code></pre></blockquote><h2 id=conditional-and><a class=header href=#conditional-and>Conditional AND</a></h2><p>Next up, constructing AND conditional using dot metacharacter and quantifiers. To allow matching in any order, you'll have to bring in alternation as well. That is somewhat manageable for 2 or 3 patterns. With PCRE, you can use <a href=./perl-compatible-regular-expressions.html#conditional-and-with-lookarounds>lookarounds for a comparatively easier approach</a>.<pre><code class=language-bash># match 'Error' followed by zero or more characters followed by 'valid'
$ echo 'Error: not a valid input' | grep -o 'Error.*valid'
Error: not a valid

$ echo 'cat and dog and parrot' | grep -oE 'cat.*dog|dog.*cat'
cat and dog
$ echo 'dog and cat and parrot' | grep -oE 'cat.*dog|dog.*cat'
dog and cat
</code></pre><h2 id=longest-match-wins><a class=header href=#longest-match-wins>Longest match wins</a></h2><p>You've already seen an example where the longest matching portion was chosen if the alternatives started from the same location. For example <code>spar|spared</code> will result in <code>spared</code> being chosen over <code>spar</code>. The same applies whenever there are two or more matching possibilities from same starting location. For example, <code>f.?o</code> will match <code>foo</code> instead of <code>fo</code> if the input string to match is <code>foot</code>.<pre><code class=language-bash># longest match among 'foo' and 'fo' wins here
$ echo 'foot' | grep -oE 'f.?o'
foo
# everything will match here
$ echo 'car bat cod map scat dot abacus' | grep -o '.*'
car bat cod map scat dot abacus

# longest match happens when (1|2|3)+ matches up to '1233' only
# so that '12apple' can match as well
$ echo 'fig123312apple' | grep -oE 'g(1|2|3)+(12apple)?'
g123312apple
# in other implementations like PCRE, that is not the case
# precedence is left to right for greedy quantifiers
$ echo 'fig123312apple' | grep -oP 'g(1|2|3)+(12apple)?'
g123312
</code></pre><p>While determining the longest match, the overall regular expression matching is also considered. That's how <code>Error.*valid</code> example worked. If <code>.*</code> had consumed everything after <code>Error</code>, there wouldn't be any more characters to try to match <code>valid</code>. So, among the varying quantity of characters to match for <code>.*</code>, the longest portion that satisfies the overall regular expression is chosen. Something like <code>a.*b</code> will match from the first <code>a</code> in the input string to the last <code>b</code>. In other implementations, like PCRE, this is achieved through a process called <strong>backtracking</strong>. These approaches have their own advantages and disadvantages and have cases where the pattern can result in exponential time consumption.<pre><code class=language-bash># extract from the start of the line to the last 'm' in the line
$ echo 'car bat cod map scat dot abacus' | grep -o '.*m'
car bat cod m

# extract from the first 'c' to the last 't' in the line
$ echo 'car bat cod map scat dot abacus' | grep -o 'c.*t'
car bat cod map scat dot

# extract from the first 'c' to the last 'at' in the line
$ echo 'car bat cod map scat dot abacus' | grep -o 'c.*at'
car bat cod map scat

# here 'm*' will match 'm' zero times as that gives the longest match
$ echo 'car bat cod map scat dot abacus' | grep -o 'b.*m*'
bat cod map scat dot abacus
</code></pre><h2 id=character-classes><a class=header href=#character-classes>Character classes</a></h2><p>To create a custom placeholder for a limited set of characters, enclose them inside <code>[]</code> metacharacters. It is similar to using single character alternations inside a grouping, but with added flexibility and features. Character classes have their own versions of metacharacters and provide special predefined sets for common use cases. Quantifiers are also applicable to character classes.<pre><code class=language-bash># same as: grep -E 'cot|cut' or grep -E 'c(o|u)t'
$ printf 'cute\ncat\ncot\ncoat\ncost\nscuttle' | grep 'c[ou]t'
cute
cot
scuttle

# same as: grep -E '(a|e|o)+t'
$ printf 'meeting\ncute\nboat\nsite\nfoot' | grep -E '[aeo]+t'
meeting
boat
foot

# same as: grep -owE '(s|o|t)(o|n)'
$ echo 'do so in to no on' | grep -ow '[sot][on]'
so
to
on

# lines made up of letters 'o' and 'n', line length at least 2
$ grep -xE '[on]{2,}' words.txt
no
non
noon
on
</code></pre><h2 id=character-class-metacharacters><a class=header href=#character-class-metacharacters>Character class metacharacters</a></h2><p>Character classes have their own metacharacters to help define the sets succinctly. Metacharacters outside of character classes like <code>^</code>, <code>$</code>, <code>()</code> etc either don't have special meaning or have a completely different one inside the character classes.<p>First up, the <code>-</code> metacharacter that helps to define a range of characters instead of having to specify them all individually.<pre><code class=language-bash># same as: grep -oE '[0123456789]+'
$ echo 'Sample123string42with777numbers' | grep -oE '[0-9]+'
123
42
777

# whole words made up of lowercase alphabets only
$ echo 'coat Bin food tar12 best' | grep -owE '[a-z]+'
coat
food
best

# whole words made up of lowercase alphabets and digits only
$ echo 'coat Bin food tar12 best' | grep -owE '[a-z0-9]+'
coat
food
tar12
best

# whole words made up of lowercase alphabets, starting with 'p' to 'z'
$ echo 'go no u grip read eat pit' | grep -owE '[p-z][a-z]*'
u
read
pit
</code></pre><p>Character classes can also be used to construct numeric ranges. However, it is easy to miss corner cases and some ranges are complicated to construct.<pre><code class=language-bash># numbers between 10 to 29
$ echo '23 154 12 26 34' | grep -ow '[12][0-9]'
23
12
26

# numbers >= 100
$ echo '23 154 12 26 98234' | grep -owE '[0-9]{3,}'
154
98234

# numbers >= 100 if there are leading zeros
$ echo '0501 035 154 12 26 98234' | grep -owE '0*[1-9][0-9]{2,}'
0501
154
98234
</code></pre><p>Next metacharacter is <code>^</code> which has to specified as the first character of the character class. It negates the set of characters, so all characters other than those specified will be matched. As highlighted earlier, handle negative logic with care, you might end up matching more than you wanted.<pre><code class=language-bash># all non-digits
$ echo 'Sample123string42with777numbers' | grep -oE '[^0-9]+'
Sample
string
with
numbers

# extract characters from the start of string based on a delimiter
$ echo 'apple:123:banana:cherry' | grep -o '^[^:]*'
apple

# extract the last two columns based on a delimiter
$ echo 'apple:123:banana:cherry' | grep -oE '(:[^:]+){2}$'
:banana:cherry

# get all sequence of characters surrounded by double quotes
$ echo 'I like "mango" and "guava"' | grep -oE '"[^"]+"'
"mango"
"guava"
</code></pre><p>Sometimes, it is easier to use positive character class and the <code>-v</code> option instead of using negated character classes.<pre><code class=language-bash># lines not containing vowel characters
# note that this will match empty lines too
$ printf 'tryst\nfun\nglyph\npity\nwhy' | grep -xE '[^aeiou]*'
tryst
glyph
why

# easier to write and maintain
$ printf 'tryst\nfun\nglyph\npity\nwhy' | grep -v '[aeiou]'
tryst
glyph
why
</code></pre><h2 id=escape-sequence-sets><a class=header href=#escape-sequence-sets>Escape sequence sets</a></h2><p>Some commonly used character sets have predefined escape sequences:<ul><li><code>\w</code> matches all <strong>word</strong> characters <code>[a-zA-Z0-9_]</code> (recall the definition for <code>-w</code>)<li><code>\W</code> matches all non-word characters (recall duality seen earlier, like <code>\b</code> and <code>\B</code>)<li><code>\s</code> matches all <strong>whitespace</strong> characters: tab, newline, vertical tab, form feed, carriage return and space<li><code>\S</code> matches all non-whitespace characters</ul><p>These escape sequences cannot be used inside character classes (unlike PCRE). Also, as mentioned earlier, these definitions assume ASCII input.<pre><code class=language-bash># extract all word character sequences
$ printf 'load;err_msg--\nant,r2..not\n' | grep -o '\w*'
load
err_msg
ant
r2
not

$ echo 'sea eat car rat eel tea' | grep -o '\b\w' | paste -sd ''
secret

# extract all non-whitespace character sequences
$ printf '   1..3  \v\f  fig_tea 42\tzzz   \r\n1-2-3\n\n' | grep -o '\S*'
1..3
fig_tea
42
zzz
1-2-3
</code></pre><h2 id=named-character-sets><a class=header href=#named-character-sets>Named character sets</a></h2><p>A <strong>named character set</strong> is defined by a name enclosed between <code>[:</code> and <code>:]</code> and has to be used within a character class <code>[]</code>, along with other characters as needed.<div class=table-wrapper><table><thead><tr><th>Named set<th>Description<tbody><tr><td><code>[:digit:]</code><td><code>[0-9]</code><tr><td><code>[:lower:]</code><td><code>[a-z]</code><tr><td><code>[:upper:]</code><td><code>[A-Z]</code><tr><td><code>[:alpha:]</code><td><code>[a-zA-Z]</code><tr><td><code>[:alnum:]</code><td><code>[0-9a-zA-Z]</code><tr><td><code>[:xdigit:]</code><td><code>[0-9a-fA-F]</code><tr><td><code>[:cntrl:]</code><td>control characters — first 32 ASCII characters and 127th (DEL)<tr><td><code>[:punct:]</code><td>all the punctuation characters<tr><td><code>[:graph:]</code><td><code>[:alnum:]</code> and <code>[:punct:]</code><tr><td><code>[:print:]</code><td><code>[:alnum:]</code>, <code>[:punct:]</code> and space<tr><td><code>[:blank:]</code><td>space and tab characters<tr><td><code>[:space:]</code><td>whitespace characters, same as <code>\s</code></table></div><p>Here are some examples:<pre><code class=language-bash>$ printf 'err_msg\nxerox\nant\nm_2\nP2\nload1\neel' | grep -x '[[:lower:]]*'
xerox
ant
eel

$ printf 'err_msg\nxerox\nant\nm_2\nP2\nload1\neel' | grep -x '[[:lower:]_]*'
err_msg
xerox
ant
eel

$ printf 'err_msg\nxerox\nant\nm_2\nP2\nload1\neel' | grep -x '[[:alnum:]]*'
xerox
ant
P2
load1
eel

$ echo 'pie tie#ink-eat_42;' | grep -o '[^[:punct:]]*'
pie tie
ink
eat
42
</code></pre><h2 id=matching-character-class-metacharacters-literally><a class=header href=#matching-character-class-metacharacters-literally>Matching character class metacharacters literally</a></h2><p>Specific placement is needed to match the character class metacharacters literally.<p><code>-</code> should be the first or last character.<pre><code class=language-bash># same as: grep -owE '[-a-z]{2,}'
$ echo 'ab-cd gh-c 12-423' | grep -owE '[a-z-]{2,}'
ab-cd
gh-c
</code></pre><p><code>]</code> should be the first character.<pre><code class=language-bash># no match
$ printf 'int a[5]\nfig\n1+1=2\n' | grep '[=]]'

# correct usage
$ printf 'int a[5]\nfig\n1+1=2\n' | grep '[]=]'
int a[5]
1+1=2
</code></pre><p><code>[</code> can be used anywhere in the character set, but not combinations like <code>[.</code> or <code>[:</code>. Using <code>[][]</code> will match both <code>[</code> and <code>]</code>.<pre><code class=language-bash>$ echo 'int a[5]' | grep '[x[.y]'
grep: Unmatched [, [^, [:, [., or [=

$ echo 'int a[5]' | grep '[x[y.]'
int a[5]
</code></pre><p><code>^</code> should be other than the first character.<pre><code class=language-bash>$ echo 'f*(a^b) - 3*(a+b)/(a-b)' | grep -o 'a[+^]b'
a^b
a+b
</code></pre><p>Characters like <code>\</code> and <code>$</code> are not special.<pre><code class=language-bash>$ echo '5ba\babc2' | grep -o '[a\b]*'
ba\bab
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> As seen in the examples above, combinations like <code>[.</code> or <code>[:</code> cannot be used together to mean two individual characters, as they have special meaning within <code>[]</code>. See <a href=https://www.gnu.org/software/grep/manual/grep.html#Character-Classes-and-Bracket-Expressions>Character Classes and Bracket Expressions</a> section in <code>info grep</code> for more details.</blockquote><h2 id=backreferences><a class=header href=#backreferences>Backreferences</a></h2><p>The grouping metacharacters <code>()</code> are also known as <strong>capture groups</strong>. Similar to variables in programming languages, the portion captured by <code>()</code> can be referred later using backreferences. The syntax is <code>\N</code> where <code>N</code> is the capture group you want. Leftmost <code>(</code> in the regular expression is <code>\1</code>, next one is <code>\2</code> and so on up to <code>\9</code>.<pre><code class=language-bash># 8 character lines having the same 3 lowercase letters at the start and end
$ grep -xE '([a-z]{3})..\1' words.txt
mesdames
respires
restores
testates
# different than: grep -xE '([a-d]..){2}'
$ grep -xE '([a-d]..)\1' words.txt
bonbon
cancan
chichi

# whole words that have at least one consecutive repeated character
$ echo 'effort flee facade oddball rat tool' | grep -owE '\w*(\w)\1\w*'
effort
flee
oddball
tool

# spot repeated words
# use \s instead of \W if only whitespaces are allowed between words
$ printf 'spot the the error\nno issues here' | grep -wE '(\w+)\W+\1'
spot the the error
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> Backreference will provide the string that was matched, not the pattern that was inside the capture group. For example, if <code>([0-9][a-f])</code> matches <code>3b</code>, then backreferencing will give <code>3b</code> and not any other valid match like <code>8f</code>, <code>0a</code> etc. This is akin to how variables behave in programming, only the result of an expression stays after variable assignment, not the expression itself.</blockquote><h2 id=known-bugs><a class=header href=#known-bugs>Known Bugs</a></h2><p>Visit <a href=https://debbugs.gnu.org/cgi/pkgreport.cgi?package=grep>grep bug list</a> for a list of known issues. See <a href=https://www.gnu.org/software/grep/manual/grep.html#Known-Bugs>GNU grep manual: Known Bugs</a> for a list of backreference related bugs.<blockquote><p>Large repetition counts in the <code>{n,m}</code> construct may cause grep to use lots of memory. In addition, certain other obscure regular expressions require exponential time and space, and may cause grep to run out of memory.<p>Back-references can greatly slow down matching, as they can generate exponentially many matching possibilities that can consume both time and memory to explore. Also, the POSIX specification for back-references is at times unclear. Furthermore, many regular expression implementations have back-reference bugs that can cause programs to return incorrect answers or even crash, and fixing these bugs has often been low-priority</blockquote><p>Here's an <a href=https://debbugs.gnu.org/cgi/bugreport.cgi?bug=26864>issue for certain usage of backreferences and quantifier</a> that was filed by yours truly.<pre><code class=language-bash># takes some time and results in no output
# aim is to get words having two occurrences of repeated characters
$ grep -m5 -xiE '([a-z]*([a-z])\2[a-z]*){2}' words.txt
# works when the nesting is unrolled
$ grep -m5 -xiE '[a-z]*([a-z])\1[a-z]*([a-z])\2[a-z]*' words.txt
Abbott
Annabelle
Annette
Appaloosa
Appleseed

# no problem if PCRE is used
$ grep -m5 -xiP '([a-z]*([a-z])\2[a-z]*){2}' words.txt
Abbott
Annabelle
Annette
Appaloosa
Appleseed
</code></pre><p><a href=https://unix.stackexchange.com/q/579889/109046>unix.stackexchange: Why doesn't this sed command replace the 3rd-to-last "and"?</a> shows another interesting bug when word boundaries and group repetitions are involved. Some examples are shown below. Again, workaround is to use PCRE or expand the group.<pre><code class=language-bash># wrong output
$ echo 'cocoa' | grep -E '(\bco){2}'
cocoa
# correct behavior, no output
$ echo 'cocoa' | grep -E '\bco\bco'
$ echo 'cocoa' | grep -P '(\bco){2}'

# wrong output
$ echo 'it line with it here sit too' | grep -oE 'with(.*\bit\b){2}'
with it here sit
# correct behavior, no output
$ echo 'it line with it here sit too' | grep -oE 'with.*\bit\b.*\bit\b'
$ echo 'it line with it here sit too' | grep -oP 'with(.*\bit\b){2}'
</code></pre><p>Changing word boundaries to <code>\<</code> and <code>\></code> results in a different issue:<pre><code class=language-bash># this correctly gives no output
$ echo 'it line with it here sit too' | grep -oE 'with(.*\&LTit\>){2}'
# this correctly gives output
$ echo 'it line with it here it too' | grep -oE 'with(.*\&LTit\>){2}'
with it here it

# but this one fails
$ echo 'it line with it here it too sit' | grep -oE 'with(.*\&LTit\>){2}'
# correct behavior
$ echo 'it line with it here it too sit' | grep -oP 'with(.*\bit\b){2}'
with it here it
</code></pre><h2 id=summary><a class=header href=#summary>Summary</a></h2><p>Mastering regular expressions is not only important for using <code>grep</code> effectively, but also comes in handy for text processing with other CLI tools like <code>sed</code> and <code>awk</code> and programming languages like <code>Python</code>, <code>Ruby</code> and <code>JavaScript</code>. These days, some of the GUI applications also support regular expressions. One main thing to remember is that syntax and features will vary. This book itself discusses four variations — BRE, ERE, PCRE and <code>ripgrep</code> regex. However, core concepts are likely to be same and having a handy reference sheet would go a long way in reducing misuse.<h2 id=exercises><a class=header href=#exercises>Exercises</a></h2><blockquote><p><img alt=info src=images/info.svg> The <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep/tree/master/exercises>exercises</a> directory has all the files used in this section.</blockquote><p><strong>1)</strong> For the input file <code>patterns.txt</code>, extract from <code>(</code> to the next occurrence of <code>)</code> unless they contain parentheses characters in between.<pre><code class=language-bash>##### add your solution here
(division)
(#modulo)
(9-2)
()
(j/k-3)
(greeting)
(b)
</code></pre><p><strong>2)</strong> For the input file <code>patterns.txt</code>, match all lines that start with <code>den</code> or end with <code>ly</code>.<pre><code class=language-bash>##### add your solution here
2 lonely
dent
lovely
</code></pre><p><strong>3)</strong> For the input file <code>patterns.txt</code>, extract all whole words containing <code>42</code> surrounded by word characters on both sides.<pre><code class=language-bash>##### add your solution here
Hi42Bye
nice1423
cool_42a
_42_
</code></pre><p><strong>4)</strong> For the input file <code>patterns.txt</code>, match all lines containing <code>car</code> but not as a whole word.<pre><code class=language-bash>##### add your solution here
scar
care
a huge discarded pile of books
scare
part cart mart
</code></pre><p><strong>5)</strong> Count the total number of times the whole words <code>removed</code> or <code>rested</code> or <code>received</code> or <code>replied</code> or <code>refused</code> or <code>retired</code> are present in the <code>patterns.txt</code> file.<pre><code class=language-bash>##### add your solution here
9
</code></pre><p><strong>6)</strong> For the input file <code>patterns.txt</code>, match lines starting with <code>s</code> and containing <code>e</code> and <code>t</code> in any order.<pre><code class=language-bash>##### add your solution here
sets tests
site cite kite bite
subtle sequoia
</code></pre><p><strong>7)</strong> From the input file <code>patterns.txt</code>, extract all whole lines having the same first and last word character.<pre><code class=language-bash>##### add your solution here
sets tests
Not a pip DOWN
y
1 dentist 1
_42_
</code></pre><p><strong>8)</strong> For the input file <code>patterns.txt</code>, match all lines containing <code>*[5]</code> literally.<pre><code class=language-bash>##### add your solution here
(9-2)*[5]
</code></pre><p><strong>9)</strong> For the given quantifiers, what would be the equivalent form using the <code>{m,n}</code> representation?<ul><li><code>?</code> is same as<li><code>*</code> is same as<li><code>+</code> is same as</ul><p><strong>10)</strong> In ERE, <code>(a*|b*)</code> is same as <code>(a|b)*</code> — True or False?<p><strong>11)</strong> <code>grep -wE '[a-z](on|no)[a-z]'</code> is same as <code>grep -wE '[a-z][on]{2}[a-z]'</code>. True or False? Sample input shown below might help to understand the differences, if any.<pre><code class=language-bash>$ printf 'known\nmood\nknow\npony\ninns\n'
known
mood
know
pony
inns
</code></pre><p><strong>12)</strong> For the input file <code>patterns.txt</code>, display all lines starting with <code>hand</code> and ending immediately with <code>s</code> or <code>y</code> or <code>le</code> or no further characters.<pre><code class=language-bash>##### add your solution here
handle
handy
hands
hand
</code></pre><p><strong>13)</strong> For the input files <code>patterns.txt</code>, display matching lines based on the patterns (one per line) present in the <code>regex_terms.txt</code> file.<pre><code class=language-bash>$ cat regex_terms.txt
^[c-k].*\W$
ly.
[A-Z].*[0-9]

##### add your solution here
Hi42Bye nice1423 bad42
fly away
def factorial()
hand 
</code></pre><p><strong>14)</strong> Will the ERE pattern <code>^a\w+([0-9]+:fig)?</code> match the same characters for the input <code>apple42:banana314</code> and <code>apple42:fig100</code>? If not, why not?<p><strong>15)</strong> For the input file <code>patterns.txt</code>, match all lines starting with <code>[5]</code>.<pre><code class=language-bash>##### add your solution here
[5]*3
</code></pre><p><strong>16)</strong> What characters will the pattern <code>\t</code> match? A tab character or <code>\</code> followed by a <code>t</code> or something else? Does the behavior change inside a character class? What alternatives are there to match a tab character?<p><strong>17)</strong> From the input file <code>patterns.txt</code>, extract all hexadecimal sequences with a minimum of four characters. Match <code>0x</code> as an optional prefix, but shouldn't be counted for determining the length. Match the characters case insensitively, and the sequences shouldn't be surrounded by other word characters.<pre><code class=language-bash>##### add your solution here
0XdeadBEEF
bad42
0x0ff1ce
</code></pre><p><strong>18)</strong> From the input file <code>patterns.txt</code>, extract from <code>-</code> till the end of the line, provided the characters after the hyphen are all word characters only.<pre><code class=language-bash>##### add your solution here
-handy
-icy
</code></pre><p><strong>19)</strong> For the input file <code>patterns.txt</code>, count the total number of lines containing <code>e</code> or <code>i</code> followed by <code>l</code> or <code>n</code> and vice versa.<pre><code class=language-bash>##### add your solution here
18
</code></pre><p><strong>20)</strong> For the input file <code>patterns.txt</code>, match lines starting with <code>4</code> or <code>-</code> or <code>u</code> or <code>sub</code> or <code>care</code>.<pre><code class=language-bash>##### add your solution here
care
4*5]
-handy
subtle sequoia
unhand
</code></pre></main><nav aria-label="Page navigation"class=nav-wrapper><a aria-label="Previous chapter"class="mobile-nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=frequently-used-options.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="mobile-nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=context-matching.html rel=next> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav aria-label="Page navigation"class=nav-wide-wrapper><a aria-label="Previous chapter"class="nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=frequently-used-options.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=context-matching.html rel=next> <i class="fa fa-angle-right"></i> </a></nav></div><script>window.playground_copyable = true;</script><script charset=utf-8 src=elasticlunr.min.js></script><script charset=utf-8 src=mark.min.js></script><script charset=utf-8 src=searcher.js></script><script charset=utf-8 src=clipboard.min.js></script><script charset=utf-8 src=highlight.js></script><script charset=utf-8 src=book.js></script><script src=sidebar.js></script>