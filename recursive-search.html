<!doctypehtml><html class="sidebar-visible no-js light"lang=en><head><meta charset=UTF-8><title>Recursive search - CLI text processing with GNU grep and ripgrep</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta content="Example based guide to mastering GNU grep and ripgrep"name=description><meta content=width=device-width,initial-scale=1 name=viewport><meta content=#ffffff name=theme-color><meta content="CLI text processing with GNU grep and ripgrep"property=og:title><meta content=website property=og:type><meta content="Example based guide to mastering GNU grep and ripgrep"property=og:description><meta content=https://learnbyexample.github.io/learn_gnugrep_ripgrep/ property=og:url><meta content=https://raw.githubusercontent.com/learnbyexample/learn_gnugrep_ripgrep/master/images/grep_ls.png property=og:image><meta content=1280 property=og:image:width><meta content=720 property=og:image:height><meta content=summary_large_image property=twitter:card><meta content=@learn_byexample property=twitter:site><link href=favicon.svg rel=icon><link rel="shortcut icon"href=favicon.png><link href=css/variables.css rel=stylesheet><link href=css/general.css rel=stylesheet><link href=css/chrome.css rel=stylesheet><link href=FontAwesome/css/font-awesome.css rel=stylesheet><link href=fonts/fonts.css rel=stylesheet><link href=highlight.css rel=stylesheet><link href=tomorrow-night.css rel=stylesheet><link href=ayu-highlight.css rel=stylesheet><link href=style.css rel=stylesheet><body><script>var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";</script><script>try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }</script><script>var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');</script><script>var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);</script><nav aria-label="Table of contents"class=sidebar id=sidebar><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=cover.html>Cover</a><li class="chapter-item expanded affix"><a href=buy.html>Buy PDF/EPUB versions</a><li class="chapter-item expanded"><a href=preface.html><strong aria-hidden=true>1.</strong> Preface</a><li class="chapter-item expanded"><a href=introduction.html><strong aria-hidden=true>2.</strong> Introduction</a><li class="chapter-item expanded"><a href=frequently-used-options.html><strong aria-hidden=true>3.</strong> Frequently used options</a><li class="chapter-item expanded"><a href=breere-regular-expressions.html><strong aria-hidden=true>4.</strong> BRE/ERE Regular Expressions</a><li class="chapter-item expanded"><a href=context-matching.html><strong aria-hidden=true>5.</strong> Context matching</a><li class="chapter-item expanded"><a class=active href=recursive-search.html><strong aria-hidden=true>6.</strong> Recursive search</a><li class="chapter-item expanded"><a href=miscellaneous-options.html><strong aria-hidden=true>7.</strong> Miscellaneous options</a><li class="chapter-item expanded"><a href=perl-compatible-regular-expressions.html><strong aria-hidden=true>8.</strong> Perl Compatible Regular Expressions</a><li class="chapter-item expanded"><a href=gotchas-and-tricks.html><strong aria-hidden=true>9.</strong> Gotchas and Tricks</a><li class="chapter-item expanded"><a href=ripgrep.html><strong aria-hidden=true>10.</strong> ripgrep</a><li class="chapter-item expanded"><a href=further-reading.html><strong aria-hidden=true>11.</strong> Further Reading</a><li class="chapter-item expanded"><a href=Exercise_solutions.html><strong aria-hidden=true>12.</strong> Exercise Solutions</a></li><br><hr><li class="chapter-item expanded"><i class="fa fa-github"id=git-repository-button></i><a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep>   Source code</a><li class="chapter-item expanded"><i class="fa fa-home"id=home-button></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i class="fa fa-book"id=book-button></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i class="fa fa-envelope"id=mail-button></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a><li class="chapter-item expanded"><i class="fa fa-twitter"id=twitter-button></i><a href=https://twitter.com/learn_byexample>   Twitter</a></ol></div><div class=sidebar-resize-handle id=sidebar-resize-handle></div></nav><div class=page-wrapper id=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div class="menu-bar sticky bordered"id=menu-bar><div class=left-buttons><button aria-label="Toggle Table of Contents"title="Toggle Table of Contents"aria-controls=sidebar class=icon-button id=sidebar-toggle type=button><i class="fa fa-bars"></i></button><button aria-label="Change theme"title="Change theme"aria-controls=theme-list aria-expanded=false aria-haspopup=true class=icon-button id=theme-toggle type=button><i class="fa fa-paint-brush"></i></button><ul aria-label=Themes class=theme-popup id=theme-list role=menu><li role=none><button class=theme id=light role=menuitem>Light (default)</button><li role=none><button class=theme id=rust role=menuitem>Rust</button><li role=none><button class=theme id=coal role=menuitem>Coal</button><li role=none><button class=theme id=navy role=menuitem>Navy</button><li role=none><button class=theme id=ayu role=menuitem>Ayu</button></ul><button aria-label="Toggle Searchbar"title="Search. (Shortkey: s)"aria-controls=searchbar aria-expanded=false aria-keyshortcuts=S class=icon-button id=search-toggle type=button><i class="fa fa-search"></i></button></div><h1 class=menu-title>CLI text processing with GNU grep and ripgrep</h1><div class=right-buttons><a aria-label=Blog href=https://learnbyexample.github.io title=Blog> <i class="fa fa-home"id=home-button></i> </a><a aria-label=Twitter href=https://twitter.com/learn_byexample title=Twitter> <i class="fa fa-twitter"id=twitter-button></i> </a><a aria-label="Git repository"title="Git repository"href=https://github.com/learnbyexample/learn_gnugrep_ripgrep> <i class="fa fa-github"id=git-repository-button></i> </a></div></div><div class=hidden id=search-wrapper><form class=searchbar-outer id=searchbar-outer><input placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header id=searchbar name=searchbar type=search></form><div class="searchresults-outer hidden"id=searchresults-outer><div class=searchresults-header id=searchresults-header></div><ul id=searchresults></ul></div></div><script>document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });</script><div class=content id=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=recursive-search><a class=header href=#recursive-search>Recursive search</a></h1><p>This chapter will cover recursive search options and ways to filter the files to be searched. Shell globs and the <code>find</code> command are also discussed to show alternate methods. You'll also learn how to pass the files filtered by <code>grep</code> to other commands for further processing.<blockquote><p><img alt=info src=images/info.svg> The <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep/tree/master/example_files>example_files</a> directory has the script used to create the sample directory for this chapter.</blockquote><h2 id=sample-directory><a class=header href=#sample-directory>Sample directory</a></h2><p>For sample files and directories used in this chapter, go to the <code>example_files</code> directory and source the <code>grep.sh</code> script.<pre><code class=language-bash>$ source grep.sh

$ tree -a
.
├── backups
│   ├── color list.txt
│   └── dot_files
│       ├── .bash_aliases
│       └── .inputrc
├── colors_1
├── colors_2
├── .hidden
└── projects
    ├── dot_files -> ../backups/dot_files
    ├── python
    │   └── hello.py
    └── shell
        └── hello.sh

6 directories, 8 files
</code></pre><h2 id=recursive-options><a class=header href=#recursive-options>Recursive options</a></h2><p>From <code>man grep</code>:<pre><code class=language-bash>-r, --recursive
      Read all files under each directory, recursively,  following
      symbolic  links  only if they are on the command line.  Note
      that if no file operand is given, grep searches the  working
      directory.  This is equivalent to the -d recurse option.

-R, --dereference-recursive
      Read  all  files  under each directory, recursively.  Follow
      all symbolic links, unlike -r.
</code></pre><blockquote><p><img alt=info src=images/info.svg> <code>-r</code> and <code>-R</code> will work as if <code>-H</code> option was specified as well, even if there is only one file found during the recursive search. Hidden files are included by default.</blockquote><p>When the above options are used, any directory in the argument list will be searched recursively. By default, the current directory will be used if there's no path specified. Here are some basic examples:<pre><code class=language-bash># current directory is the default path to be searched recursively
# show all matching lines containing 'clear'
$ grep -r 'clear'
.hidden:clear blue sky
backups/dot_files/.bash_aliases:alias c=clear

# without filename prefix
$ grep -rh 'clear'
clear blue sky
alias c=clear

# list of files containing 'blue'
$ grep -rl 'blue'
.hidden
colors_1
colors_2
backups/color list.txt

# list of files NOT containing 'blue'
$ grep -rL 'blue'
projects/python/hello.py
projects/shell/hello.sh
backups/dot_files/.bash_aliases
backups/dot_files/.inputrc
</code></pre><p>If links are provided as part of the argument list, <code>grep</code> will perform a search within that path even if only the <code>-r</code> option is used. The <code>-R</code> option will follow links even when they are not part of the argument list.<pre><code class=language-bash># -r will not follow links
$ grep -rl 'pwd'
backups/dot_files/.bash_aliases

# link provided as an argument will be searched even with -r
$ grep -rl 'pwd' backups projects/dot_files
backups/dot_files/.bash_aliases
projects/dot_files/.bash_aliases

# -R will automatically follow links
$ grep -Rl 'pwd'
projects/dot_files/.bash_aliases
backups/dot_files/.bash_aliases
</code></pre><h2 id=customize-search-path><a class=header href=#customize-search-path>Customize search path</a></h2><p>By default, the recursive search options <code>-r</code> and <code>-R</code> will include hidden files as well. There are situations, such as version controlled directories, where specific paths should be ignored or all the files mentioned in a specific file should be ignored. To aid in such custom searches, four options are available:<div class=table-wrapper><table><thead><tr><th>Option<th>Description<tbody><tr><td>--include=GLOB<td>search only files that match GLOB (a file pattern)<tr><td>--exclude=GLOB<td>skip files that match GLOB<tr><td>--exclude-from=FILE<td>skip files that match any file pattern from FILE<tr><td>--exclude-dir=GLOB<td>skip directories that match GLOB</table></div><blockquote><p><img alt=info src=images/info.svg> <code>GLOB</code> here refers to wildcard patterns (also known as globs) used by the shell to expand filenames. These are NOT the same as regular expressions. When recursive options are used, the <code>GLOB</code> applies only to the basename of a file or directory, not the entire path. For more information about globs, see this <a href=https://mywiki.wooledge.org/glob>mywiki.wooledge</a> article.</blockquote><p>Here are some basic examples:<pre><code class=language-bash># without filename filtering
$ grep -rl 'blue'
.hidden
colors_1
colors_2
backups/color list.txt

# search only filenames ending with '.txt'
$ grep -rl --include='*.txt' 'blue'
backups/color list.txt

# exclude filenames ending with '.txt' or starting with '.hi'
$ printf '*.txt\n.hi*' | grep -rl --exclude-from=- 'blue'
colors_1
colors_2
</code></pre><p>Each of these options can be used multiple times to narrow your search.<pre><code class=language-bash># excluding 'backups' directory and hidden files
$ grep -rl --exclude-dir='backups' --exclude='.*' 'blue'
colors_1
colors_2

# allow only filenames ending with '.txt' or starting with '.hi'
$ grep -rl --include='*.txt' --include='.hi*' 'blue'
.hidden
backups/color list.txt
</code></pre><p>If you mix <code>--include</code> and <code>--exclude</code> options, their order of declaration matters.<pre><code class=language-bash># here, exclude gets countered by the include option
$ grep -rl --exclude='*.sh' --include='*ll*' 'He'
projects/python/hello.py
projects/shell/hello.sh

# files ending with '.sh' are excluded as expected
$ grep -rl --include='*ll*' --exclude='*.sh' 'He'
projects/python/hello.py
</code></pre><blockquote><p><img alt=info src=images/info.svg> As mentioned earlier, these options can be used even when recursive search isn't active.<pre><code class=language-bash>$ grep -l --exclude='*.sh' 'He' projects/*/*
projects/python/hello.py

$ grep -l --include='*.sh' 'He' projects/*/*
projects/shell/hello.sh
</code></pre></blockquote><h2 id=extglob-and-globstar><a class=header href=#extglob-and-globstar>extglob and globstar</a></h2><p>Modern versions of shells like <code>bash</code> and <code>zsh</code> provide advanced wildcard matching. These can be used instead of <code>-r</code> and <code>-R</code> options for some cases. See my blog posts on <a href=https://learnbyexample.github.io/tips/cli-tip-19/>extended globs</a> and <a href=https://learnbyexample.github.io/tips/cli-tip-23/>globstar</a> for more details on these shell options.<pre><code class=language-bash># same as: grep -rl --include='*.txt' --include='*.py' --include='*.sh' 'r'
# to include hidden files, 'dotglob' shell option should be set as well
$ shopt -s extglob globstar
$ grep -l 'r' **/*.@(txt|py|sh)
backups/color list.txt
projects/python/hello.py
</code></pre><p>In the above example, <code>**</code> indicates that you need recursive matching from that point onwards. <code>@(pattern-list)</code> helps to provide alternate patterns to be matched, with common parts outside this grouping.<p>Wildcard matching doesn't distinguish between directories and files. So, you might have to use <code>-d skip</code> to prevent <code>grep</code> from treating directories as input files to be searched. Here's an example:<pre><code class=language-bash>$ printf '%s\n' **/*py*
projects/python
projects/python/hello.py

$ grep -l 'on' **/*py*
grep: projects/python: Is a directory
projects/python/hello.py

$ grep -d skip -l 'on' **/*py*
projects/python/hello.py
</code></pre><h2 id=find-command><a class=header href=#find-command>find command</a></h2><p>The <code>find</code> command is even more versatile than recursive options and advanced wildcard matching. Apart from searching based on filename, it has provisions to match based on file properties like size and time.<pre><code class=language-bash># files (including hidden ones) with size less than 25 bytes
# '-type f' helps to match only files
# -L option tells find to follow links
$ find -L -type f -size -25c
./projects/python/hello.py
./projects/shell/hello.sh
./.hidden
./backups/color list.txt

# apply 'grep' only for the files filtered by the find command
$ find -L -type f -size -25c -exec grep 'e$' {} +
./backups/color list.txt:blue
</code></pre><blockquote><p><img alt=info src=images/info.svg> See <a href=https://learnbyexample.github.io/cli-computing/searching-files-and-filenames.html#find>find chapter</a> from my <a href=https://github.com/learnbyexample/cli-computing>Linux Command Line Computing</a> ebook for more details about this command.</blockquote><h2 id=piping-filenames><a class=header href=#piping-filenames>Piping filenames</a></h2><p>Suppose a command gives a list of filenames and you want to pass this list as input <em>arguments</em> to another command, what would you do? One solution is to use the <code>xargs</code> command. Here's a basic example (assuming filenames won't conflict with shell metacharacters):<pre><code class=language-bash># an example command producing a list of filenames
$ grep -rl 'clear'
.hidden
backups/dot_files/.bash_aliases

# same as: head -n1 .hidden backups/dot_files/.bash_aliases
$ grep -rl 'clear' | xargs head -n1
==> .hidden <==
ghost

==> backups/dot_files/.bash_aliases <==
alias p=pwd
</code></pre><p>Characters like space, newline, semicolon, etc are special to the shell. You have to properly quote filenames containing such metacharacters. Or, where applicable, you can use a list of filenames separated by the ASCII NUL character (since filenames cannot have the NUL character). You can use <code>grep -Z</code> to separate the output with NUL and <code>xargs -0</code> to treat the input as NUL separated. Here's an example:<pre><code class=language-bash># consider this command that generates a list of filenames
$ grep -rl 'blue'
.hidden
colors_1
colors_2
backups/color list.txt

# example to show issues due to filenames containing shell metacharacters
# 'backups/color list.txt' is treated as two different files
$ grep -rl 'blue' | xargs grep -l 'teal'
colors_1
grep: backups/color: No such file or directory
grep: list.txt: No such file or directory

# use 'grep -Z' + 'xargs -0' combo for a robust solution
# match files containing both 'blue' and 'teal'
$ grep -rlZ 'blue' | xargs -0 grep -l 'teal'
colors_1
</code></pre><p>Note that the command passed to <code>xargs</code> doesn't accept custom made aliases and functions. So, if you had aliased <code>grep</code> to <code>grep --color=auto</code>, don't be surprised if the output isn't colorized. See <a href=https://unix.stackexchange.com/q/141367/109046>unix.stackexchange: have xargs use alias instead of binary</a> for details and workarounds.<blockquote><p><img alt=info src=./images/info.svg> You can use <code>xargs -r</code> to avoid running the command when the filename list doesn't have any non-blank character (i.e. when the list is effectively empty).<pre><code class=language-bash># there's no file containing 'violet'
# so, xargs doesn't get any filename, but grep is still run
$ grep -rlZ 'violet' | xargs -0 grep -L 'brown'
(standard input)

# use the -r option to avoid running the command in such cases
$ grep -rlZ 'violet' | xargs -r0 grep -L 'brown'
</code></pre></blockquote><blockquote><p><img alt=warning src=images/warning.svg> <img alt=warning src=images/warning.svg> Do not use <code>xargs -P</code> to combine the output of parallel runs, unless you know how to manage output buffers and thus prevent mangled result. The <a href=https://www.gnu.org/software/parallel/>parallel</a> command would be a better option. See <a href=https://unix.stackexchange.com/q/104778/109046>unix.stackexchange: xargs vs parallel</a> for more details. See also <a href=https://unix.stackexchange.com/q/24954/109046>unix.stackexchange: when to use xargs</a>.</blockquote><h2 id=summary><a class=header href=#summary>Summary</a></h2><p>Having recursive options when there is already <code>find</code> command seems unnecessary, but in my opinion, these options are highly convenient. Some cases may require falling back to shell globs or <code>find</code> or even a combination of these methods. Modern tools like <code>ripgrep</code> provide a default recursive search behavior, with out-of-box features like ignoring hidden files, respecting <code>.gitignore</code> rules, parallel execution and so on.<h2 id=exercises><a class=header href=#exercises>Exercises</a></h2><blockquote><p><img alt=info src=images/info.svg> Use the <code>recursive.sh</code> script from the <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep/tree/master/exercises>exercises</a> directory for this section. Unless otherwise mentioned, assume you need to use the <code>-r</code> option instead of <code>-R</code>.<pre><code class=language-bash># change to the 'exercises' directory and source the 'recursive.sh' script
$ source recursive.sh

$ tree -a
.
├── backups
│   ├── color list.txt
│   ├── dot_files
│   │   ├── .bash_aliases
│   │   └── .inputrc
│   └── text
│       └── pat.txt -> ../../../patterns.txt
├── colors_1
├── colors_2.txt
├── .hidden
├── projects
│   ├── python
│   │   └── hello.py
│   └── shell
│       └── hello.sh
├── sample_file.txt -> ../sample.txt
└── substitute.sh

6 directories, 11 files
</code></pre></blockquote><p><strong>1)</strong> Search recursively and display the lines containing <code>ello</code>. Output should not have filename prefix.<pre><code class=language-bash>##### add your solution here
    print("Hello, Python!")
echo "Hello, Bash!"
yellow
yellow
</code></pre><p><strong>2)</strong> Search recursively and list the names of files containing <code>blue</code> or <code>on</code> or a double quote character. Match all of these terms only at the end of a line.<pre><code class=language-bash>##### add your solution here
projects/shell/hello.sh
colors_1
colors_2.txt
backups/dot_files/.inputrc
backups/color list.txt
</code></pre><p><strong>3)</strong> Search recursively and list the names of files containing <code>blue</code>, but do not search within the <code>backups</code> directory.<pre><code class=language-bash>##### add your solution here
.hidden
colors_1
colors_2.txt
</code></pre><p><strong>4)</strong> Search recursively within the <code>backups</code> directory and list the names of files containing <code>red</code>. Symbolic links found in this directory should be searched as well.<pre><code class=language-bash>##### add your solution here
backups/color list.txt
backups/text/pat.txt
</code></pre><p><strong>5)</strong> Search recursively and list the names of files that do <em>not</em> contain <code>greeting</code> or <code>blue</code>. Symbolic links should be searched as well.<pre><code class=language-bash>##### add your solution here
projects/shell/hello.sh
substitute.sh
sample_file.txt
backups/dot_files/.bash_aliases
backups/dot_files/.inputrc
</code></pre><p><strong>6)</strong> Search for files containing <code>red</code> or <code>ello</code> recursively, but do not list the file if it also contains <code>greeting</code>.<pre><code class=language-bash>##### add your solution here
projects/shell/hello.sh
colors_1
colors_2.txt
</code></pre><p><strong>7)</strong> Search recursively only within filenames ending with <code>.txt</code> and display the names of files containing <code>red</code>. Symbolic links should be searched as well.<pre><code class=language-bash>##### add your solution here
colors_2.txt
backups/color list.txt
backups/text/pat.txt
</code></pre><p><strong>8)</strong> Search recursively only within filenames ending with <code>.txt</code> but not if the name has a space character. Display the names of files containing <code>red</code>. Symbolic links should be searched as well.<pre><code class=language-bash>##### add your solution here
colors_2.txt
backups/text/pat.txt
</code></pre><p><strong>9)</strong> Which option will you use if you have a file with a list of glob patterns to identify filenames to be excluded?<p><strong>10)</strong> Does the glob pattern provided to <code>include</code> and <code>exclude</code> options match only the basename or the entire file path? Assume that recursive search is active.<p><strong>11)</strong> How would you tell <code>grep</code> to avoid treating directory arguments as input files to be searched?<p><strong>12)</strong> Use a combination of <code>find</code> and <code>grep</code> commands to display lines containing a whole word <code>Hi</code> only for symbolic links.<pre><code class=language-bash>##### add your solution here
./sample_file.txt:Hi there
./backups/text/pat.txt:Hi there(greeting). Nice day(a(b)
</code></pre><p><strong>13)</strong> Search recursively and list the names of files that contain <code>Hello</code> or <code>blue</code>. Symbolic links should be searched as well. Do not search within <code>python</code> or <code>backups</code> directories.<pre><code class=language-bash>##### add your solution here
projects/shell/hello.sh
.hidden
colors_1
sample_file.txt
colors_2.txt
</code></pre><p><strong>14)</strong> Search recursively only within filenames ending with <code>.txt</code> and count the total number of lines containing <code>car</code> or <code>blue</code> or a digit character. Symbolic links should be searched as well.<pre><code class=language-bash>##### add your solution here
21
</code></pre><p><strong>15)</strong> Display lines containing <code>Hello</code> or <code>red</code> only from files in the current hierarchy, i.e. don't search recursively. Symbolic links should be searched as well.<pre><code class=language-bash>##### add your solution here
colors_2.txt:red
sample_file.txt:Hello World
</code></pre><p><strong>16)</strong> Search recursively for files containing <code>blue</code> as well as <code>yellow</code> anywhere in the file, but do not list the file if it also contains <code>teal</code>.<pre><code class=language-bash>##### add your solution here
colors_2.txt
</code></pre></main><nav aria-label="Page navigation"class=nav-wrapper><a aria-label="Previous chapter"class="mobile-nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=context-matching.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="mobile-nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=miscellaneous-options.html rel=next> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav aria-label="Page navigation"class=nav-wide-wrapper><a aria-label="Previous chapter"class="nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=context-matching.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=miscellaneous-options.html rel=next> <i class="fa fa-angle-right"></i> </a></nav></div><script>window.playground_copyable = true;</script><script charset=utf-8 src=elasticlunr.min.js></script><script charset=utf-8 src=mark.min.js></script><script charset=utf-8 src=searcher.js></script><script charset=utf-8 src=clipboard.min.js></script><script charset=utf-8 src=highlight.js></script><script charset=utf-8 src=book.js></script><script src=sidebar.js></script>