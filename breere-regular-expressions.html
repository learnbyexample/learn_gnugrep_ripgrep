<!DOCTYPE HTML><html lang=en class="sidebar-visible no-js light"><head><meta charset=UTF-8><title>BRE/ERE Regular Expressions - GNU GREP and RIPGREP</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta name=description content="Example based guide to mastering GNU GREP and RIPGREP"><meta name=viewport content="width=device-width, initial-scale=1"><meta name=theme-color content=#ffffff><link rel=icon href=favicon.svg><link rel="shortcut icon"href=favicon.png><link rel=stylesheet href=css/variables.css><link rel=stylesheet href=css/general.css><link rel=stylesheet href=css/chrome.css><link rel=stylesheet href=FontAwesome/css/font-awesome.css><link rel=stylesheet href=fonts/fonts.css><link rel=stylesheet href=highlight.css><link rel=stylesheet href=tomorrow-night.css><link rel=stylesheet href=ayu-highlight.css><link rel=stylesheet href=style.css><body><script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script><script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script><script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script><script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script><nav id=sidebar class=sidebar aria-label="Table of contents"><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=cover.html>Cover</a><li class="chapter-item expanded affix"><a href=buy.html>Buy PDF/EPUB versions</a><li class="chapter-item expanded"><a href=preface.html><strong aria-hidden=true>1.</strong> Preface</a><li class="chapter-item expanded"><a href=introduction.html><strong aria-hidden=true>2.</strong> Introduction</a><li class="chapter-item expanded"><a href=frequently-used-options.html><strong aria-hidden=true>3.</strong> Frequently used options</a><li class="chapter-item expanded"><a href=breere-regular-expressions.html class=active><strong aria-hidden=true>4.</strong> BRE/ERE Regular Expressions</a><li class="chapter-item expanded"><a href=context-matching.html><strong aria-hidden=true>5.</strong> Context matching</a><li class="chapter-item expanded"><a href=recursive-search.html><strong aria-hidden=true>6.</strong> Recursive search</a><li class="chapter-item expanded"><a href=miscellaneous-options.html><strong aria-hidden=true>7.</strong> Miscellaneous options</a><li class="chapter-item expanded"><a href=perl-compatible-regular-expressions.html><strong aria-hidden=true>8.</strong> Perl Compatible Regular Expressions</a><li class="chapter-item expanded"><a href=gotchas-and-tricks.html><strong aria-hidden=true>9.</strong> Gotchas and Tricks</a><li class="chapter-item expanded"><a href=ripgrep.html><strong aria-hidden=true>10.</strong> ripgrep</a><li class="chapter-item expanded"><a href=further-reading.html><strong aria-hidden=true>11.</strong> Further Reading</a><li class="chapter-item expanded"><a href=Exercise_solutions.html><strong aria-hidden=true>12.</strong> Exercise Solutions</a></li><br><hr><li class="chapter-item expanded"><i id=git-repository-button class="fa fa-github"></i><a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep>   Source code</a><li class="chapter-item expanded"><i id=home-button class="fa fa-home"></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i id=book-button class="fa fa-book"></i><a href=https://learnbyexample.github.io/books/>   My Books</a></ol></div><div id=sidebar-resize-handle class=sidebar-resize-handle></div></nav><div id=page-wrapper class=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div id=menu-bar class="menu-bar sticky bordered"><div class=left-buttons><button id=sidebar-toggle class=icon-button type=button title="Toggle Table of Contents"aria-label="Toggle Table of Contents"aria-controls=sidebar><i class="fa fa-bars"></i></button><button id=theme-toggle class=icon-button type=button title="Change theme"aria-label="Change theme"aria-haspopup=true aria-expanded=false aria-controls=theme-list><i class="fa fa-paint-brush"></i></button><ul id=theme-list class=theme-popup aria-label=Themes role=menu><li role=none><button role=menuitem class=theme id=light>Light (default)</button><li role=none><button role=menuitem class=theme id=rust>Rust</button><li role=none><button role=menuitem class=theme id=coal>Coal</button><li role=none><button role=menuitem class=theme id=navy>Navy</button><li role=none><button role=menuitem class=theme id=ayu>Ayu</button></ul><button id=search-toggle class=icon-button type=button title="Search. (Shortkey: s)"aria-label="Toggle Searchbar"aria-expanded=false aria-keyshortcuts=S aria-controls=searchbar><i class="fa fa-search"></i></button></div><h1 class=menu-title>GNU GREP and RIPGREP</h1><div class=right-buttons><a href=https://learnbyexample.github.io title=Blog aria-label=Blog> <i id=home-button class="fa fa-home"></i> </a><a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep title="Git repository"aria-label="Git repository"> <i id=git-repository-button class="fa fa-github"></i> </a></div></div><div id=search-wrapper class=hidden><form id=searchbar-outer class=searchbar-outer><input type=search name=search id=searchbar name=searchbar placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header></form><div id=searchresults-outer class="searchresults-outer hidden"><div id=searchresults-header class=searchresults-header></div><ul id=searchresults></ul></div></div><script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script><div id=content class=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=breere-regular-expressions><a class=header href=#breere-regular-expressions>BRE/ERE Regular Expressions</a></h1><p>This chapter will cover Basic and Extended Regular Expressions as implemented in <code>GNU grep</code>. Though not strictly conforming to <a href=%5Bhttps://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.%5D(https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.)html>POSIX specifications</a>, most of it is applicable to other <code>grep</code> implementations as well. Unless otherwise indicated, examples and descriptions will assume ASCII input. <code>GNU grep</code> also supports Perl Compatible Regular Expressions, which will be covered in a later chapter.<p>By default, <code>grep</code> treats the search pattern as Basic Regular Expression (BRE)<ul><li><code>-G</code> option can be used to specify explicitly that BRE is needed<li><code>-E</code> option will enable Extended Regular Expression (ERE) <ul><li>in <code>GNU grep</code>, BRE and ERE only differ in how metacharacters are specified, no difference in features</ul><li><code>-F</code> option will cause the search patterns to be treated literally<li><code>-P</code> if available, this option will enable Perl Compatible Regular Expression (PCRE)</ul><blockquote><p><img src=images/info.svg alt=info> Files used in examples are available chapter wise from <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep/tree/master/example_files>learn_gnugrep_ripgrep repo</a>. The directory for this chapter is <code>bre_ere</code>.</blockquote><h2 id=line-anchors><a class=header href=#line-anchors>Line Anchors</a></h2><p>Instead of matching anywhere in the line, restrictions can be specified. For now, you'll see the ones that are already part of BRE/ERE. In later sections and chapters, you'll get to know how to define your own rules for restriction. These restrictions are made possible by assigning special meaning to certain characters and escape sequences. The characters with special meaning are known as <strong>metacharacters</strong> in regular expressions parlance. In case you need to match those characters literally, you need to escape them with a <code>\</code> (discussed in <a href=./breere-regular-expressions.html#escaping-metacharacters>Escaping metacharacters</a> section).<p>There are two line anchors:<ul><li><code>^</code> metacharacter restricts the matching to the start of line<li><code>$</code> metacharacter restricts the matching to the end of line</ul><pre><code class=language-bash>$ # lines starting with 'pa'
$ printf 'spared no one\npar\nspar\ndare' | grep '^pa'
par

$ # lines ending with 'ar'
$ printf 'spared no one\npar\nspar\ndare' | grep 'ar$'
par
spar

$ # lines containing only 'par'
$ printf 'spared no one\npar\nspar\ndare' | grep '^par$'
par
$ printf 'spared no one\npar\nspar\ndare' | grep -x 'par'
par
</code></pre><h2 id=word-anchors><a class=header href=#word-anchors>Word Anchors</a></h2><p>The second type of restriction is word anchors. A word character is any alphabet (irrespective of case), digit and the underscore character. This is similar to using <code>-w</code> option, with added flexibility of using word anchor only at the start/end of a word.<p>The escape sequence <code>\b</code> denotes a word boundary. This works for both start of word and end of word anchoring. Start of word means either the character prior to the word is a non-word character or there is no character (start of line). Similarly, end of word means the character after the word is a non-word character or no character (end of line). This implies that you cannot have word boundary without a word character.<blockquote><p><img src=images/info.svg alt=info> As an alternate, you can use <code>\<</code> to indicate start of word anchor and <code>\></code> to indicate end of word anchor. Using <code>\b</code> is preferred as it is more commonly used in other regular expression implementations and has <code>\B</code> as its opposite.</blockquote><blockquote><p><img src=images/warning.svg alt=warning> Word boundaries behave a bit differently than <code>-w</code> option. See <a href=./gotchas-and-tricks.html#word-boundary-differences>Word boundary differences</a> section for details.</blockquote><pre><code class=language-bash>$ cat word_anchors.txt
sub par
spar
apparent effort
two spare computers
cart part tart mart

$ # match words starting with 'par'
$ grep '\bpar' word_anchors.txt
sub par
cart part tart mart

$ # match words ending with 'par'
$ grep 'par\b' word_anchors.txt
sub par
spar

$ # match only whole word 'par'
$ grep '\bpar\b' word_anchors.txt
sub par
$ grep -w 'par' word_anchors.txt
sub par
</code></pre><p>The word boundary has an opposite anchor too. <code>\B</code> matches wherever <code>\b</code> doesn't match. This duality will be seen with some other escape sequences too.<pre><code class=language-bash>$ # match 'par' if it is surrounded by word characters
$ grep '\Bpar\B' word_anchors.txt
apparent effort
two spare computers

$ # match 'par' but not as start of word
$ grep '\Bpar' word_anchors.txt
spar
apparent effort
two spare computers

$ # match 'par' but not as end of word
$ grep 'par\B' word_anchors.txt
apparent effort
two spare computers
cart part tart mart
</code></pre><blockquote><p><img src=images/warning.svg alt=warning> Negative logic is handy in many text processing situations. But use it with care, you might end up matching things you didn't intend.</blockquote><h2 id=alternation><a class=header href=#alternation>Alternation</a></h2><p>Many a times, you'd want to search for multiple terms. In a conditional expression, you can use the logical operators to combine multiple conditions. With regular expressions, the <code>|</code> metacharacter is similar to logical OR. The regular expression will match if any of the expression separated by <code>|</code> is satisfied. These can have their own independent anchors as well.<p>Alternation is similar to using multiple <code>-e</code> option, but provides more flexibility when combined with grouping. The <code>|</code> metacharacter syntax varies between BRE and ERE. Quoting from the manual:<blockquote><p>In basic regular expressions the meta-characters <code>?</code>, <code>+</code>, <code>{</code>, <code>|</code>, <code>(</code>, and <code>)</code> lose their special meaning; instead use the backslashed versions <code>\?</code>, <code>\+</code>, <code>\{</code>, <code>\|</code>, <code>\(</code>, and <code>\)</code>.</blockquote><pre><code class=language-bash>$ # three different ways to match either 'cat' or 'dog'
$ printf 'I like cats\nI like parrots\nI like dogs' | grep 'cat\|dog'
I like cats
I like dogs
$ printf 'I like cats\nI like parrots\nI like dogs' | grep -E 'cat|dog'
I like cats
I like dogs
$ printf 'I like cats\nI like parrots\nI like dogs' | grep -e 'cat' -e 'dog'
I like cats
I like dogs

$ # extract either 'cat' or 'dog' or 'fox' case insensitively
$ printf 'CATs dog bee parrot FoX' | grep -ioE 'cat|dog|fox'
CAT
dog
FoX

$ # match lines starting with 'a' or a line containing a word ending with 'e'
$ grep -E '^a|e\b' word_anchors.txt
apparent effort
two spare computers
</code></pre><p>A cool use case of alternation is combining line anchors to display entire input file but highlight only required search patterns. Standalone line anchors will match every input line, even empty lines as they are position markers.<p><img src=./images/highlight_patterns.png alt="highlighting patterns in whole input"><p>There's some tricky situations when using alternation. If it is used for filtering a line, there is no ambiguity. However, for matching portion extraction with <code>-o</code> option, it depends on a few factors. Say, you want to extract <code>are</code> or <code>spared</code> — which one should get precedence? The bigger word <code>spared</code> or the substring <code>are</code> inside it or based on something else?<p>The alternative which matches earliest in the input gets precedence.<pre><code class=language-bash>$ echo 'car spared spar' | grep -oE 'are|spared'
spared
$ echo 'car spared spar' | grep -oE 'spared|are'
spared
</code></pre><p>In case of matches starting from same location, for example <code>party</code> and <code>par</code>, the longest matching portion gets precedence. See <a href=./breere-regular-expressions.html#longest-match-wins>Longest match wins</a> section for more examples. See <a href=https://www.regular-expressions.info/alternation.html>regular-expressions: alternation</a> for more information on this topic.<pre><code class=language-bash>$ # same output irrespective of alternation order
$ echo 'pool party 2' | grep -oE 'party|par'
party
$ echo 'pool party 2' | grep -oE 'par|party'
party

$ # other implementations like PCRE have left-to-right priority
$ echo 'pool party 2' | grep -oP 'par|party'
par
</code></pre><h2 id=grouping><a class=header href=#grouping>Grouping</a></h2><p>Often, there are some common things among the regular expression alternatives. It could be common characters or qualifiers like the anchors. In such cases, you can group them using a pair of parentheses metacharacters. Similar to <code>a(b+c)d = abd+acd</code> in maths, you get <code>a(b|c)d = abd|acd</code> in regular expressions.<pre><code class=language-bash>$ # without grouping
$ printf 'red\nreform\nread\narrest' | grep -E 'reform|rest'
reform
arrest
$ # with grouping
$ printf 'red\nreform\nread\narrest' | grep -E 're(form|st)'
reform
arrest

$ # without grouping
$ printf 'sub par\nspare\npart time' | grep -E '\bpar\b|\bpart\b'
sub par
part time
$ # taking out common anchors
$ printf 'sub par\nspare\npart time' | grep -E '\b(par|part)\b'
sub par
part time
$ # taking out common characters as well
$ # you'll later learn a better technique instead of using empty alternate
$ printf 'sub par\nspare\npart time' | grep -E '\bpar(|t)\b'
sub par
part time
</code></pre><h2 id=escaping-metacharacters><a class=header href=#escaping-metacharacters>Escaping metacharacters</a></h2><p>You have seen a few metacharacters and escape sequences that help to compose a regular expression. To match the metacharacters literally, i.e. to remove their special meaning, prefix those characters with a <code>\</code> character. To indicate a literal <code>\</code> character, use <code>\\</code>. Some of the metacharacters, like the line anchors, lose their special meaning when not used in their customary positions with BRE syntax.<p>If there are many metacharacters to be escaped, try to work out if the command can be simplified by using <code>-F</code> (paired with regular expression like options such as <code>-e</code>, <code>-f</code>, <code>-i</code>, <code>-w</code>, <code>-x</code>, etc) or by switching between ERE and BRE. Another option is to use PCRE (covered later), which has special constructs to mark whole or portion of pattern to be matched literally — especially useful when using shell variables.<pre><code class=language-bash>$ # line anchors aren't special away from customary positions with BRE
$ echo 'a^2 + b^2 - C*3' | grep 'b^2'
a^2 + b^2 - C*3
$ echo '$a = $b + $c' | grep '$b'
$a = $b + $c
$ # escape line anchors to match literally if you are using ERE
$ # or if you want to match them at customary positions with BRE
$ echo '$a = $b + $c' | grep -o '\$' | wc -l
3
$ # or use -F where possible
$ echo '$a = $b + $c' | grep -oF '$' | wc -l
3

$ # BRE vs ERE
$ # cannot use -F here as line anchor is needed
$ printf '(a/b) + c\n3 + (a/b) - c' | grep '^(a/b)'
(a/b) + c
$ printf '(a/b) + c\n3 + (a/b) - c' | grep -E '^\(a/b)'
(a/b) + c
</code></pre><h2 id=matching-characters-like-tabs><a class=header href=#matching-characters-like-tabs>Matching characters like tabs</a></h2><p><code>GNU grep</code> doesn't support escape sequences like <code>\t</code> (commonly used to represent tab character). Neither does it support formats like <code>\xNN</code> (specifying a character by its ASCII value in hexadecimal format). As an alternate, you can use <code>bash</code> <a href=https://www.gnu.org/software/bash/manual/bash.html#ANSI_002dC-Quoting>ANSI-C Quoting</a> feature to use such escape sequences.<pre><code class=language-bash>$ # any undefined escape sequence is treated as the character it escapes
$ # here \t is same as t
$ echo 'attempt' | grep -o 'a\tt'
att

$ # here $'..' is a bash feature to enable use of escape sequences
$ printf 'go\tto\ngo to' | grep $'go\tto'
go      to

$ # \x20 is hexadecimal for space character
$ printf 'go\tto\ngo to' | grep $'go\x20to'
go to
</code></pre><h2 id=the-dot-meta-character><a class=header href=#the-dot-meta-character>The dot meta character</a></h2><p>The dot metacharacter serves as a placeholder to match any character. Later you'll learn how to define your own custom placeholder for limited set of characters.<pre><code class=language-bash># extract 'c', followed by any character and then 't'
$ echo 'tac tin cot abc:tuv excite' | grep -o 'c.t'
c t
cot
c:t
cit

$ printf '42\t33\n'
42      33
# extract '2', followed by any character and then '3'
$ printf '42\t33\n' | grep -o '2.3'
2       3
</code></pre><p>If you are using a Unix-like distribution, you'll likely have <code>/usr/share/dict/words</code> dictionary file. This will be used as input file to illustrate regular expression examples. It is included in the <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep/blob/master/example_files/bre_ere/words.txt>learn_gnugrep_ripgrep repo</a> as <code>words.txt</code> file (modified to make it ASCII only).<pre><code class=language-bash>$ # 5 character lines starting with 'c' and ending with 'ty' or 'ly'
$ grep -xE 'c..(t|l)y' words.txt
catty
coyly
curly
</code></pre><h2 id=quantifiers><a class=header href=#quantifiers>Quantifiers</a></h2><p>As an analogy, alternation provides logical OR. Combining the dot metacharacter <code>.</code> and quantifiers (and alternation if needed) paves a way to perform logical AND. For example, to check if a string matches two patterns with any number of characters in between. Quantifiers can be applied to both characters and groupings. Apart from ability to specify exact quantity and bounded range, these can also match unbounded varying quantities. BRE/ERE support only one type of quantifiers, whereas PCRE supports three types. Quantifiers in <code>GNU grep</code> behave mostly like greedy quantifiers supported by PCRE, but there are subtle differences, which will be discussed with examples later on.<p>First up, the <code>?</code> metacharacter which quantifies a character or group to match <code>0</code> or <code>1</code> times. This helps to define optional patterns and build terser patterns compared to groupings for some cases.<pre><code class=language-bash>$ # same as: grep -E '\b(fe.d|fed)\b'
$ # BRE version: grep -w 'fe.\?d'
$ printf 'fed\nfod\nfe:d\nfeed' | grep -wE 'fe.?d'
fed
fe:d
feed

$ # same as: grep -E '\bpar(|t)\b'
$ printf 'sub par\nspare\npart time' | grep -wE 'part?'
sub par
part time

$ # same as: grep -oE 'part|parrot'
$ echo 'par part parrot parent' | grep -oE 'par(ro)?t'
part
parrot
$ # same as: grep -oE 'part|parrot|parent'
$ echo 'par part parrot parent' | grep -oE 'par(en|ro)?t'
part
parrot
parent
</code></pre><p>The <code>*</code> metacharacter quantifies a character or group to match <code>0</code> or more times. There is no upper bound, more details will be discussed in the next section.<pre><code class=language-bash>$ # extract 'f' followed by zero or more of 'e' followed by 'd'
$ echo 'fd fed fod fe:d feeeeder' | grep -o 'fe*d'
fd
fed
feeeed

$ # extract zero or more of '1' followed by '2'
$ echo '3111111111125111142' | grep -o '1*2'
11111111112
2
</code></pre><p>The <code>+</code> metacharacter quantifies a character or group to match <code>1</code> or more times. Similar to <code>*</code> quantifier, there is no upper bound.<pre><code class=language-bash>$ # extract 'f' followed by one or more of 'e' followed by 'd'
$ # BRE version: grep -o 'fe\+d'
$ echo 'fd fed fod fe:d feeeeder' | grep -oE 'fe+d'
fed
feeeed

$ # extract 'f' followed by at least one of 'e' or 'o' or ':' followed by 'd'
$ echo 'fd fed fod fe:d feeeeder' | grep -oE 'f(e|o|:)+d'
fed
fod
fe:d
feeeed

$ # extract one or more of '1' followed by '2'
$ echo '3111111111125111142' | grep -oE '1+2'
11111111112
$ # extract one or more of '1' followed by optional '4' and then '2'
$ echo '3111111111125111142' | grep -oE '1+4?2'
11111111112
111142
</code></pre><p>You can specify a range of integer numbers, both bounded and unbounded, using <code>{}</code> metacharacters. There are four ways to use this quantifier as listed below:<table><thead><tr><th>Pattern<th>Description<tbody><tr><td><code>{m,n}</code><td>match <code>m</code> to <code>n</code> times<tr><td><code>{m,}</code><td>match at least <code>m</code> times<tr><td><code>{,n}</code><td>match up to <code>n</code> times (including <code>0</code> times)<tr><td><code>{n}</code><td>match exactly <code>n</code> times</table><pre><code class=language-bash>$ # note that space is not allowed after ,
$ # BRE version: grep -o 'ab\{1,4\}c'
$ echo 'abc ac adc abbc xabbbcz bbb bc abbbbbc' | grep -oE 'ab{1,4}c'
abc
abbc
abbbc

$ echo 'abc ac adc abbc xabbbcz bbb bc abbbbbc' | grep -oE 'ab{3,}c'
abbbc
abbbbbc

$ echo 'abc ac adc abbc xabbbcz bbb bc abbbbbc' | grep -oE 'ab{,2}c'
abc
ac
abbc

$ echo 'abc ac adc abbc xabbbcz bbb bc abbbbbc' | grep -oE 'ab{3}c'
abbbc
</code></pre><blockquote><p><img src=images/info.svg alt=info> To match <code>{}</code> metacharacters literally (assuming ERE), escaping <code>{</code> alone is enough. Or if it doesn't conform strictly to any of the four forms listed above, escaping is not needed at all.</blockquote><p>Next up, how to construct AND conditional using dot metacharacter and quantifiers. To allow matching in any order, you'll have to bring in alternation as well. That is somewhat manageable for 2 or 3 patterns. With PCRE, you can use lookarounds for a comparatively easier approach.<pre><code class=language-bash>$ # match 'Error' followed by zero or more characters followed by 'valid'
$ echo 'Error: not a valid input' | grep -o 'Error.*valid'
Error: not a valid

$ echo 'a cat and a dog' | grep -E 'cat.*dog|dog.*cat'
a cat and a dog
$ echo 'dog and cat' | grep -E 'cat.*dog|dog.*cat'
dog and cat
</code></pre><h2 id=longest-match-wins><a class=header href=#longest-match-wins>Longest match wins</a></h2><p>You've already seen an example with alternation, where the longest matching portion was chosen if two alternatives started from same location. For example <code>spar|spared</code> will result in <code>spared</code> being chosen over <code>spar</code>. The same applies whenever there are two or more matching possibilities from same starting location. For example, <code>f.?o</code> will match <code>foo</code> instead of <code>fo</code> if the input string to match is <code>foot</code>.<pre><code class=language-bash>$ # longest match among 'foo' and 'fo' wins here
$ echo 'foot' | grep -oE 'f.?o'
foo
$ # everything will match here
$ echo 'car bat cod map scat dot abacus' | grep -o '.*'
car bat cod map scat dot abacus

$ # longest match happens when (1|2|3)+ matches up to '1233' only
$ # so that '12baz' can match as well
$ echo 'foo123312baz' | grep -oE 'o(1|2|3)+(12baz)?'
o123312baz
$ # in other implementations like PCRE, that is not the case
$ # precedence is left to right for greedy quantifiers
$ echo 'foo123312baz' | grep -oP 'o(1|2|3)+(12baz)?'
o123312
</code></pre><p>While determining the longest match, overall regular expression matching is also considered. That's how <code>Error.*valid</code> example worked. If <code>.*</code> had consumed everything after <code>Error</code>, there wouldn't be any more characters to try to match <code>valid</code>. So, among the varying quantity of characters to match for <code>.*</code>, the longest portion that satisfies the overall regular expression is chosen. Something like <code>a.*b</code> will match from first <code>a</code> in the input string to the last <code>b</code> in the string. In other implementations, like PCRE, this is achieved through a process called <strong>backtracking</strong>. Both approaches have their own advantages and disadvantages and have cases where the pattern can result in exponential time consumption.<pre><code class=language-bash>$ # extract from start of line to last 'm' in the line
$ echo 'car bat cod map scat dot abacus' | grep -o '.*m'
car bat cod m

$ # extract from first 'c' to last 't' in the line
$ echo 'car bat cod map scat dot abacus' | grep -o 'c.*t'
car bat cod map scat dot

$ # extract from first 'c' to last 'at' in the line
$ echo 'car bat cod map scat dot abacus' | grep -o 'c.*at'
car bat cod map scat

$ # here 'm*' will match 'm' zero times as that gives the longest match
$ echo 'car bat cod map scat dot abacus' | grep -o 'b.*m*'
bat cod map scat dot abacus
</code></pre><h2 id=character-classes><a class=header href=#character-classes>Character classes</a></h2><p>To create a custom placeholder for limited set of characters, enclose them inside <code>[]</code> metacharacters. It is similar to using single character alternations inside a grouping, but with added flexibility and features. Character classes have their own versions of metacharacters and provide special predefined sets for common use cases. Quantifiers are also applicable to character classes.<pre><code class=language-bash>$ # same as: grep -E 'cot|cut' or grep -E 'c(o|u)t'
$ printf 'cute\ncat\ncot\ncoat\ncost\nscuttle' | grep 'c[ou]t'
cute
cot
scuttle

$ # same as: grep -E '(a|e|o)+t'
$ printf 'meeting\ncute\nboat\nsite\nfoot' | grep -E '[aeo]+t'
meeting
boat
foot

$ # same as: grep -owE '(s|o|t)(o|n)'
$ echo 'do so in to no on' | grep -ow '[sot][on]'
so
to
on

$ # lines made up of letters 'o' and 'n', line length at least 2
$ grep -xE '[on]{2,}' words.txt
no
non
noon
on
</code></pre><p>Character classes have their own metacharacters to help define the sets succinctly. Metacharacters outside of character classes like <code>^</code>, <code>$</code>, <code>()</code> etc either don't have special meaning or have completely different one inside the character classes. First up, the <code>-</code> metacharacter that helps to define a range of characters instead of having to specify them all individually.<pre><code class=language-bash>$ # same as: grep -oE '[0123456789]+'
$ echo 'Sample123string42with777numbers' | grep -oE '[0-9]+'
123
42
777

$ # whole words made up of lowercase alphabets only
$ echo 'coat Bin food tar12 best' | grep -owE '[a-z]+'
coat
food
best

$ # whole words made up of lowercase alphabets and digits only
$ echo 'coat Bin food tar12 best' | grep -owE '[a-z0-9]+'
coat
food
tar12
best

$ # whole words made up of lowercase alphabets, starting with 'p' to 'z'
$ echo 'go no u grip read eat pit' | grep -owE '[p-z][a-z]*'
u
read
pit
</code></pre><p>Character classes can also be used to construct numeric ranges. However, it is easy to miss corner cases and some ranges are complicated to design.<pre><code class=language-bash>$ # numbers between 10 to 29
$ echo '23 154 12 26 34' | grep -ow '[12][0-9]'
23
12
26

$ # numbers >= 100
$ echo '23 154 12 26 98234' | grep -owE '[0-9]{3,}'
154
98234

$ # numbers >= 100 if there are leading zeros
$ echo '0501 035 154 12 26 98234' | grep -owE '0*[1-9][0-9]{2,}'
0501
154
98234
</code></pre><p>Next metacharacter is <code>^</code> which has to specified as the first character of the character class. It negates the set of characters, so all characters other than those specified will be matched. As highlighted earlier, handle negative logic with care, you might end up matching more than you wanted.<pre><code class=language-bash>$ # all non-digits
$ echo 'Sample123string42with777numbers' | grep -oE '[^0-9]+'
Sample
string
with
numbers

$ # extract characters from start of string based on a delimiter
$ echo 'foo=42; baz=123' | grep -o '^[^=]*'
foo

$ # extract last two columns based on a delimiter
$ echo 'foo:123:bar:baz' | grep -oE '(:[^:]+){2}$'
:bar:baz

$ # get all sequence of characters surrounded by unique character
$ echo 'I like "mango" and "guava"' | grep -oE '"[^"]+"'
"mango"
"guava"
</code></pre><p>Sometimes, it is easier to use positive character class and <code>-v</code> option instead of using negated character class.<pre><code class=language-bash>$ # lines not containing vowel characters
$ # note that this will match empty lines too
$ printf 'tryst\nfun\nglyph\npity\nwhy' | grep -xE '[^aeiou]*'
tryst
glyph
why

$ # easier to write and maintain
$ printf 'tryst\nfun\nglyph\npity\nwhy' | grep -v '[aeiou]'
tryst
glyph
why
</code></pre><p>Some commonly used character sets have predefined escape sequences:<ul><li><code>\w</code> matches all <strong>word</strong> characters <code>[a-zA-Z0-9_]</code> (recall the description for <code>-w</code> option)<li><code>\W</code> matches all non-word characters (recall duality seen earlier, like <code>\b</code> and <code>\B</code>)<li><code>\s</code> matches all <strong>whitespace</strong> characters: tab, newline, vertical tab, form feed, carriage return and space<li><code>\S</code> matches all non-whitespace characters</ul><p>These escape sequences cannot be used inside character classes (but PCRE allows this). Also, as mentioned earlier, these definitions assume ASCII input.<pre><code class=language-bash>$ # extract all word character sequences
$ printf 'load;err_msg--\nant,r2..not\n' | grep -o '\w*'
load
err_msg
ant
r2
not

$ # extract all non-whitespace character sequences
$ printf '   1..3  \v\f  foo_baz 42\tzzz   \r\n1-2-3\n\n' | grep -o '\S*'
1..3
foo_baz
42
zzz
1-2-3
</code></pre><p>A <strong>named character set</strong> is defined by a name enclosed between <code>[:</code> and <code>:]</code> and has to be used within a character class <code>[]</code>, along with any other characters as needed.<table><thead><tr><th>Named set<th>Description<tbody><tr><td><code>[:digit:]</code><td><code>[0-9]</code><tr><td><code>[:lower:]</code><td><code>[a-z]</code><tr><td><code>[:upper:]</code><td><code>[A-Z]</code><tr><td><code>[:alpha:]</code><td><code>[a-zA-Z]</code><tr><td><code>[:alnum:]</code><td><code>[0-9a-zA-Z]</code><tr><td><code>[:xdigit:]</code><td><code>[0-9a-fA-F]</code><tr><td><code>[:cntrl:]</code><td>control characters — first 32 ASCII characters and 127th (DEL)<tr><td><code>[:punct:]</code><td>all the punctuation characters<tr><td><code>[:graph:]</code><td><code>[:alnum:]</code> and <code>[:punct:]</code><tr><td><code>[:print:]</code><td><code>[:alnum:]</code>, <code>[:punct:]</code> and space<tr><td><code>[:blank:]</code><td>space and tab characters<tr><td><code>[:space:]</code><td>whitespace characters, same as <code>\s</code></table><pre><code class=language-bash>$ printf 'err_msg\nxerox\nant\nm_2\nP2\nload1\neel' | grep -x '[[:lower:]]*'
xerox
ant
eel

$ printf 'err_msg\nxerox\nant\nm_2\nP2\nload1\neel' | grep -x '[[:lower:]_]*'
err_msg
xerox
ant
eel

$ printf 'err_msg\nxerox\nant\nm_2\nP2\nload1\neel' | grep -x '[[:alnum:]]*'
xerox
ant
P2
load1
eel

$ echo 'pie tie#ink-eat_42;' | grep -o '[^[:punct:]]*'
pie tie
ink
eat
42
</code></pre><p>Specific placement is needed to match character class metacharacters literally.<blockquote><p><img src=images/warning.svg alt=warning> Combinations like <code>[.</code> or <code>[:</code> cannot be used together to mean two individual characters, as they have special meaning within <code>[]</code>. See <a href=https://www.gnu.org/software/grep/manual/grep.html#Character-Classes-and-Bracket-Expressions>Character Classes and Bracket Expressions</a> section in <code>info grep</code> for more details.</blockquote><pre><code class=language-bash>$ # - should be first or last character within []
$ echo 'ab-cd gh-c 12-423' | grep -owE '[a-z-]{2,}'
ab-cd
gh-c

$ # ] should be first character within []
$ printf 'int a[5]\nfoo\n1+1=2\n' | grep '[=]]'
$ printf 'int a[5]\nfoo\n1+1=2\n' | grep '[]=]'
int a[5]
1+1=2

$ # to match [ use [ anywhere in the character set
$ # but not combinations like [. or [:
$ # [][] will match both [ and ]
$ echo 'int a[5]' | grep '[x[.y]'
grep: Unmatched [, [^, [:, [., or [=
$ echo 'int a[5]' | grep '[x[y.]'
int a[5]

$ # ^ should be other than first character within []
$ echo 'f*(a^b) - 3*(a+b)/(a-b)' | grep -o 'a[+^]b'
a^b
a+b

$ # characters like \ and $ are not special within []
$ echo '5ba\babc2' | grep -o '[a\b]*'
ba\bab
</code></pre><h2 id=backreferences><a class=header href=#backreferences>Backreferences</a></h2><p>The grouping metacharacters <code>()</code> are also known as <strong>capture groups</strong>. Similar to variables in programming languages, the string captured by <code>()</code> can be referred later using backreference <code>\N</code> where <code>N</code> is the capture group you want. Leftmost <code>(</code> in the regular expression is <code>\1</code>, next one is <code>\2</code> and so on up to <code>\9</code>.<blockquote><p><img src=images/warning.svg alt=warning> Backreference will provide the string that was matched, not the pattern that was inside the capture group. For example, if <code>([0-9][a-f])</code> matches <code>3b</code>, then backreferencing will give <code>3b</code> and not any other valid match like <code>8f</code>, <code>0a</code> etc. This is akin to how variables behave in programming, only the result of expression stays after variable assignment, not the expression itself.</blockquote><pre><code class=language-bash>$ # 8 character lines having same 3 lowercase letters at start and end
$ grep -xE '([a-z]{3})..\1' words.txt
mesdames
respires
restores
testates
$ # different than: grep -xE '([a-d]..){2}'
$ grep -xE '([a-d]..)\1' words.txt
bonbon
cancan
chichi

$ # whole words that have at least one consecutive repeated character
$ echo 'effort flee facade oddball rat tool' | grep -owE '\w*(\w)\1\w*'
effort
flee
oddball
tool

$ # same word next to each other
$ # use \s instead of \W if only whitespaces are allowed between words
$ printf 'spot the the error\nno issues here' | grep -wE '(\w+)\W+\1'
spot the the error
</code></pre><h2 id=known-bugs><a class=header href=#known-bugs>Known Bugs</a></h2><p>Visit <a href=https://debbugs.gnu.org/cgi/pkgreport.cgi?package=grep>grep bug list</a> for a list of known issues. See <a href=https://www.gnu.org/software/grep/manual/grep.html#Known-Bugs>GNU grep manual: Known Bugs</a> for a list of backreference related bugs.<p>From <code>man grep</code> under <strong>Known Bugs</strong> section:<blockquote><p>Large repetition counts in the {n,m} construct may cause grep to use lots of memory. In addition, certain other obscure regular expressions require exponential time and space, and may cause grep to run out of memory. Back-references are very slow, and may require exponential time.</blockquote><p>Here's an <a href=https://debbugs.gnu.org/cgi/bugreport.cgi?bug=26864>issue for certain usage of backreferences and quantifier</a> that was filed by yours truly.<pre><code class=language-bash>$ # takes some time and results in no output
$ # aim is to get words having two occurrences of repeated characters
$ grep -m5 -xiE '([a-z]*([a-z])\2[a-z]*){2}' words.txt
$ # works when nesting is unrolled
$ grep -m5 -xiE '[a-z]*([a-z])\1[a-z]*([a-z])\2[a-z]*' words.txt
Abbott
Annabelle
Annette
Appaloosa
Appleseed

$ # no problem if PCRE is used
$ grep -m5 -xiP '([a-z]*([a-z])\2[a-z]*){2}' words.txt
Abbott
Annabelle
Annette
Appaloosa
Appleseed
</code></pre><blockquote><p><img src=images/warning.svg alt=warning> <a href=https://unix.stackexchange.com/q/579889/109046>unix.stackexchange: Why doesn't this sed command replace the 3rd-to-last "and"?</a> shows another interesting bug when word boundaries and group repetition are involved. Some examples are shown below. Again, workaround is to use PCRE or expand the group.</blockquote><pre><code class=language-bash>$ # wrong output
$ echo 'cocoa' | grep -E '(\bco){2}'
cocoa
$ # correct behavior, no output
$ echo 'cocoa' | grep -E '\bco\bco'
$ echo 'cocoa' | grep -P '(\bco){2}'

$ # wrong output
$ echo 'it line with it here sit too' | grep -oE 'with(.*\bit\b){2}'
with it here sit
$ # correct behavior, no output
$ echo 'it line with it here sit too' | grep -oE 'with.*\bit\b.*\bit\b'
$ echo 'it line with it here sit too' | grep -oP 'with(.*\bit\b){2}'

$ # changing word boundaries to \< and \> results in a different problem
$ # this correctly gives no output
$ echo 'it line with it here sit too' | grep -oE 'with(.*\&LTit\>){2}'
$ # this correctly gives output
$ echo 'it line with it here it too' | grep -oE 'with(.*\&LTit\>){2}'
with it here it
$ # but this one fails
$ echo 'it line with it here it too sit' | grep -oE 'with(.*\&LTit\>){2}'
$ echo 'it line with it here it too sit' | grep -oP 'with(.*\bit\b){2}'
with it here it
</code></pre><h2 id=summary><a class=header href=#summary>Summary</a></h2><p>Knowing regular expressions very well is not only important to use <code>grep</code> effectively, but also comes in handy when moving onto use regular expressions in other tools like <code>sed</code> and <code>awk</code> and programming languages like <code>Python</code> and <code>Ruby</code>. These days, some of the GUI applications also support regular expressions. One main thing to remember is that syntax and features will vary. This book itself discusses five variations — BRE, ERE, PCRE, Rust regex and PCRE2. However, core concepts are likely to be same and having a handy reference sheet would go a long way in reducing misuse.<h2 id=exercises><a class=header href=#exercises>Exercises</a></h2><p><strong>a)</strong> Extract all pairs of <code>()</code> with/without text inside them, provided they do not contain <code>()</code> characters inside.<pre><code class=language-bash>$ echo 'I got (12) apples' | grep ##### add your solution here
(12)

$ echo '((2 +3)*5)=25 and (4.3/2*()' | grep ##### add your solution here
(2 +3)
()
</code></pre><p><strong>b)</strong> For the given input, match all lines that start with <code>den</code> or end with <code>ly</code><pre><code class=language-bash>$ lines='lovely\n1 dentist\n2 lonely\neden\nfly away\ndent'
$ printf '%b' "$lines" | grep ##### add your solution here
lovely
2 lonely
dent
</code></pre><p><strong>c)</strong> Extract all whole words that contains <code>42</code> but not at edge of word. Assume a word cannot contain <code>42</code> more than once.<pre><code class=language-bash>$ echo 'hi42bye nice1423 bad42 cool_42a 42fake' | grep ##### add your solution here
hi42bye
nice1423
cool_42a
</code></pre><p><strong>d)</strong> Each line in given input contains a single word. Match all lines containing <code>car</code> but not as a whole word.<pre><code class=language-bash>$ printf 'car\nscar\ncare\npot\nscare\n' | grep ##### add your solution here
scar
care
scare
</code></pre><p><strong>e)</strong> For <code>dracula.txt</code> file, count the total number of lines that contain <code>removed</code> or <code>rested</code> or <code>received</code> or <code>replied</code> or <code>refused</code> or <code>retired</code> as whole words.<pre><code class=language-bash>$ grep ##### add your solution here
73
</code></pre><p><strong>f)</strong> Extract words starting with <code>s</code> and containing <code>e</code> and <code>t</code> in any order.<pre><code class=language-bash>$ words='sequoia subtle exhibit sets tests sit'
$ echo "$words" | grep ##### add your solution here
subtle
sets
</code></pre><p><strong>g)</strong> Extract all whole words having the same first and last character.<pre><code class=language-bash>$ echo 'oreo not a pip roar took 22' | grep ##### add your solution here
oreo
a
pip
roar
22
</code></pre><p><strong>h)</strong> Match all lines containing <code>*[5]</code><pre><code class=language-bash>$ printf '4*5]\n(9-2)*[5]\n[5]*3\nr*[5\n' | grep ##### add your solution here
(9-2)*[5]
</code></pre><p><strong>i)</strong> For the given quantifiers, what would be the equivalent form using <code>{m,n}</code> representation?<ul><li><code>?</code> is same as<li><code>*</code> is same as<li><code>+</code> is same as</ul><p><strong>j)</strong> In ERE, <code>(a*|b*)</code> is same as <code>(a|b)*</code> — True or False?<p><strong>k)</strong> <code>grep -wE '[a-z](on|no)[a-z]'</code> is same as <code>grep -wE '[a-z][on]{2}[a-z]'</code>. True or False? Sample input shown below might help to understand the differences, if any.<pre><code class=language-bash>$ printf 'known\nmood\nknow\npony\ninns\n'
known
mood
know
pony
inns
</code></pre><p><strong>l)</strong> Display all lines that start with <code>hand</code> and ends with no further character or <code>s</code> or <code>y</code> or <code>le</code>.<pre><code class=language-bash>$ lines='handed\nhand\nhandy\nunhand\nhands\nhandle\n'
$ printf '%b' "$lines" | grep ##### add your solution here
hand
handy
hands
handle
</code></pre></main><nav class=nav-wrapper aria-label="Page navigation"><a rel=prev href=frequently-used-options.html class="mobile-nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=context-matching.html class="mobile-nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav class=nav-wide-wrapper aria-label="Page navigation"><a rel=prev href=frequently-used-options.html class="nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=context-matching.html class="nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a></nav></div><script>
            window.playground_copyable = true;
        </script><script src=elasticlunr.min.js charset=utf-8></script><script src=mark.min.js charset=utf-8></script><script src=searcher.js charset=utf-8></script><script src=clipboard.min.js charset=utf-8></script><script src=highlight.js charset=utf-8></script><script src=book.js charset=utf-8></script><script src=sidebar.js></script>