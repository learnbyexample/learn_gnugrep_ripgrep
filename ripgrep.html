<!doctypehtml><html class="sidebar-visible no-js light"lang=en><head><meta charset=UTF-8><title>ripgrep - CLI text processing with GNU grep and ripgrep</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta content="Example based guide to mastering GNU grep and ripgrep"name=description><meta content=width=device-width,initial-scale=1 name=viewport><meta content=#ffffff name=theme-color><meta content="CLI text processing with GNU grep and ripgrep"property=og:title><meta content=website property=og:type><meta content="Example based guide to mastering GNU grep and ripgrep"property=og:description><meta content=https://learnbyexample.github.io/learn_gnugrep_ripgrep/ property=og:url><meta content=https://raw.githubusercontent.com/learnbyexample/learn_gnugrep_ripgrep/master/images/grep_ls.png property=og:image><meta content=1280 property=og:image:width><meta content=720 property=og:image:height><meta content=summary_large_image property=twitter:card><meta content=@learn_byexample property=twitter:site><link href=favicon.svg rel=icon><link rel="shortcut icon"href=favicon.png><link href=css/variables.css rel=stylesheet><link href=css/general.css rel=stylesheet><link href=css/chrome.css rel=stylesheet><link href=FontAwesome/css/font-awesome.css rel=stylesheet><link href=fonts/fonts.css rel=stylesheet><link href=highlight.css rel=stylesheet><link href=tomorrow-night.css rel=stylesheet><link href=ayu-highlight.css rel=stylesheet><link href=style.css rel=stylesheet><body><script>var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";</script><script>try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }</script><script>var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');</script><script>var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);</script><nav aria-label="Table of contents"class=sidebar id=sidebar><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=cover.html>Cover</a><li class="chapter-item expanded affix"><a href=buy.html>Buy PDF/EPUB versions</a><li class="chapter-item expanded"><a href=preface.html><strong aria-hidden=true>1.</strong> Preface</a><li class="chapter-item expanded"><a href=introduction.html><strong aria-hidden=true>2.</strong> Introduction</a><li class="chapter-item expanded"><a href=frequently-used-options.html><strong aria-hidden=true>3.</strong> Frequently used options</a><li class="chapter-item expanded"><a href=breere-regular-expressions.html><strong aria-hidden=true>4.</strong> BRE/ERE Regular Expressions</a><li class="chapter-item expanded"><a href=context-matching.html><strong aria-hidden=true>5.</strong> Context matching</a><li class="chapter-item expanded"><a href=recursive-search.html><strong aria-hidden=true>6.</strong> Recursive search</a><li class="chapter-item expanded"><a href=miscellaneous-options.html><strong aria-hidden=true>7.</strong> Miscellaneous options</a><li class="chapter-item expanded"><a href=perl-compatible-regular-expressions.html><strong aria-hidden=true>8.</strong> Perl Compatible Regular Expressions</a><li class="chapter-item expanded"><a href=gotchas-and-tricks.html><strong aria-hidden=true>9.</strong> Gotchas and Tricks</a><li class="chapter-item expanded"><a class=active href=ripgrep.html><strong aria-hidden=true>10.</strong> ripgrep</a><li class="chapter-item expanded"><a href=further-reading.html><strong aria-hidden=true>11.</strong> Further Reading</a><li class="chapter-item expanded"><a href=Exercise_solutions.html><strong aria-hidden=true>12.</strong> Exercise Solutions</a></li><br><hr><li class="chapter-item expanded"><i class="fa fa-github"id=git-repository-button></i><a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep>   Source code</a><li class="chapter-item expanded"><i class="fa fa-home"id=home-button></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i class="fa fa-book"id=book-button></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i class="fa fa-envelope"id=mail-button></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a><li class="chapter-item expanded"><i class="fa fa-twitter"id=twitter-button></i><a href=https://twitter.com/learn_byexample>   Twitter</a></ol></div><div class=sidebar-resize-handle id=sidebar-resize-handle></div></nav><div class=page-wrapper id=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div class="menu-bar sticky bordered"id=menu-bar><div class=left-buttons><button aria-label="Toggle Table of Contents"title="Toggle Table of Contents"aria-controls=sidebar class=icon-button id=sidebar-toggle type=button><i class="fa fa-bars"></i></button><button aria-label="Change theme"title="Change theme"aria-controls=theme-list aria-expanded=false aria-haspopup=true class=icon-button id=theme-toggle type=button><i class="fa fa-paint-brush"></i></button><ul aria-label=Themes class=theme-popup id=theme-list role=menu><li role=none><button class=theme id=light role=menuitem>Light (default)</button><li role=none><button class=theme id=rust role=menuitem>Rust</button><li role=none><button class=theme id=coal role=menuitem>Coal</button><li role=none><button class=theme id=navy role=menuitem>Navy</button><li role=none><button class=theme id=ayu role=menuitem>Ayu</button></ul><button aria-label="Toggle Searchbar"title="Search. (Shortkey: s)"aria-controls=searchbar aria-expanded=false aria-keyshortcuts=S class=icon-button id=search-toggle type=button><i class="fa fa-search"></i></button></div><h1 class=menu-title>CLI text processing with GNU grep and ripgrep</h1><div class=right-buttons><a aria-label=Blog href=https://learnbyexample.github.io title=Blog> <i class="fa fa-home"id=home-button></i> </a><a aria-label=Twitter href=https://twitter.com/learn_byexample title=Twitter> <i class="fa fa-twitter"id=twitter-button></i> </a><a aria-label="Git repository"title="Git repository"href=https://github.com/learnbyexample/learn_gnugrep_ripgrep> <i class="fa fa-github"id=git-repository-button></i> </a></div></div><div class=hidden id=search-wrapper><form class=searchbar-outer id=searchbar-outer><input placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header id=searchbar name=searchbar type=search></form><div class="searchresults-outer hidden"id=searchresults-outer><div class=searchresults-header id=searchresults-header></div><ul id=searchresults></ul></div></div><script>document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });</script><div class=content id=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=ripgrep><a class=header href=#ripgrep>ripgrep</a></h1><p><code>ripgrep</code> is a very popular alternative to the <code>grep</code> command. Editors like <em>Visual Studio Code</em> are using <code>ripgrep</code> to power their search and replace features. The major selling point is its default behavior for recursive search, parallel processing and speed. <code>ripgrep</code> doesn't aim to be compatible with POSIX or <code>GNU grep</code> and there are various differences in terms of features, option names, output style, regular expressions and so on.<h2 id=project-links><a class=header href=#project-links>Project links</a></h2><ul><li><a href=https://github.com/BurntSushi/ripgrep>GitHub: ripgrep</a><li><a href=https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md>User guide</a><li><a href=https://github.com/BurntSushi/ripgrep/issues>Issue manager</a><li><a href=https://github.com/BurntSushi/ripgrep/discussions>Discussions</a><li><a href=https://github.com/BurntSushi/ripgrep/blob/master/FAQ.md>FAQ</a></ul><blockquote><p><img alt=info src=images/info.svg> See <a href=https://beyondgrep.com/feature-comparison/>Feature comparison of ack, ag, git-grep, GNU grep and ripgrep</a> for an overview of features among various <code>grep</code> implementations. See also <a href=https://blog.burntsushi.net/ripgrep/>benchmark among grep implementations</a>.</blockquote><h2 id=installation><a class=header href=#installation>Installation</a></h2><p>See <a href=https://github.com/BurntSushi/ripgrep/blob/master/README.md#installation>ripgrep: installation</a> for details on various methods and platforms. Instructions shown below is for Debian-like distributions.<pre><code class=language-bash># link shown here on two lines as it is too long
# visit using the first part to get latest version
$ link='https://github.com/BurntSushi/ripgrep/releases/'
$ link="$link"'download/13.0.0/ripgrep_13.0.0_amd64.deb'
$ wget "$link"
$ sudo gdebi ripgrep_13.0.0_amd64.deb

# note that the installed command name is rg, not ripgrep
$ rg --version
ripgrep 13.0.0 (rev 7ec2fd51ba)
-SIMD -AVX (compiled)
+SIMD -AVX (runtime)
</code></pre><h2 id=command-line-text-processing-with-rust-tools><a class=header href=#command-line-text-processing-with-rust-tools>Command line text processing with Rust tools</a></h2><p>Earlier versions of this book discussed <code>ripgrep</code> from the basics, just like <code>GNU grep</code>. That led to a lot of repetitive details that were very similar to <code>GNU grep</code>. This chapter will now cover only notable features and differences.<p>You can still access the earlier version from my work-in-progress <a href=https://learnbyexample.github.io/cli_text_processing_rust/>Command line text processing with Rust tools</a> ebook.<h2 id=default-behavior-differences><a class=header href=#default-behavior-differences>Default behavior differences</a></h2><p>Here are some notable differences in behavior between <code>ripgrep</code> and <code>GNU grep</code> when they are invoked without any options:<ul><li>Regular expressions flavor is provided by the <a href=https://docs.rs/regex/latest/regex/>regex crate</a> <ul><li>to put it roughly, this provides more features compared to BRE/ERE but less compared to PCRE</ul><li>Line number prefix and color options are enabled by default<li>Blank line separates matching lines from different files<li>Filename is added as a prefix line above the matching lines instead of a prefix for each matching line<li>Recursive search is on by default for directories provided as an argument (current directory if input source is not specified). In addition, <ul><li>files and directories that match rules specified by ignore files like <code>.gitignore</code> are not searched<li>hidden files and directories are ignored<li>binary files (determined by the presence of the ASCII NUL character) are ignored, but a matching line is displayed if found before encountering the NUL character along with a warning</ul></ul><h2 id=options-overview><a class=header href=#options-overview>Options overview</a></h2><p>It is always a good idea to know where to find the documentation. From command line, you can use <code>man rg</code> for the manual and <code>rg -h</code> for a list of all the options. See also <a href=https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md>ripgrep: User guide</a>.<p>This section will cover some of the options provided by <code>ripgrep</code> with examples. As mentioned earlier, the focus will be on differences compared to <code>GNU grep</code>. So, options like <code>-F</code>, <code>-f</code>, <code>-i</code>, <code>-o</code>, <code>-v</code>, <code>-w</code>, <code>-x</code>, <code>-m</code>, <code>-q</code>, <code>-b</code>, <code>-A</code>, <code>-B</code> and <code>-C</code> won't be discussed as they behave the same as <code>GNU grep</code>. Regular expressions will be covered in a later section.<blockquote><p><img alt=info src=images/info.svg> The <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep/tree/master/example_files>example_files</a> directory has all the files used in the examples.</blockquote><h3 id=line-number><a class=header href=#line-number>Line number</a></h3><p>As mentioned earlier, line number prefix is enabled by default. However, if the output is redirected or if the input is being read from <code>stdin</code>, this option won't be on by default. You can override the default behavior by using <code>-n</code> to always add the line number prefix and <code>-N</code> to turn off the numbering.<pre><code class=language-bash># default behavior
$ rg 'day' ip.txt
1:it is a warm and cozy day
$ printf 'apple\nbanana\ncherry' | rg 'an'
banana

# using options explicitly
$ rg -N 'day' ip.txt
it is a warm and cozy day
$ printf 'apple\nbanana\ncherry' | rg -n 'an'
2:banana
</code></pre><p>Here are some examples with output redirection:<pre><code class=language-bash># saving output to a file
$ rg 'to' ip.txt > out.txt
$ cat out.txt
listen to what I say
There are so many delights to cherish
$ rm out.txt

# passing output to another command
$ rg 'to' ip.txt | rg 'many'
There are so many delights to cherish

# use options explicitly if required
$ rg -n 'to' ip.txt | rg 'many'
6:There are so many delights to cherish
</code></pre><h3 id=count><a class=header href=#count>Count</a></h3><p>Unlike <code>GNU grep</code>, the <code>-c</code> will not display files that don't have a match. You can add the <code>--include-zero</code> option to display files without matches as well.<pre><code class=language-bash>$ rg -c 'to' ip.txt search.txt
ip.txt:2

$ rg -c --include-zero 'to' ip.txt search.txt
search.txt:0
ip.txt:2
</code></pre><p>When <code>-o</code> is combined with <code>-c</code>, you'll get the total count of matches. Unlike <code>GNU grep</code>, you don't have to use another command like <code>wc</code>. You can also use <code>--count-matches</code> instead of the <code>-co</code> combination.<pre><code class=language-bash>$ rg -co 'an' ip.txt
6

$ rg --count-matches 'an' ip.txt
6
</code></pre><h3 id=get-filename-instead-of-matching-lines><a class=header href=#get-filename-instead-of-matching-lines>Get filename instead of matching lines</a></h3><p>Similar to <code>GNU grep</code>, you can use <code>-l</code> or <code>--files-with-matches</code> to get filenames when a match is found. But the <code>-L</code> option in <code>ripgrep</code> is used to follow links, so only the long option <code>--files-without-match</code> is available to get filenames when a match is <em>not</em> found.<pre><code class=language-bash>$ rg --files-without-match 'to' ip.txt search.txt
search.txt
</code></pre><h3 id=filename-prefix-for-matching-lines><a class=header href=#filename-prefix-for-matching-lines>Filename prefix for matching lines</a></h3><p>Filename prefix is automatically added for recursive search and multiple file arguments. You can use <code>-H</code> to always show the prefix and <code>-I</code> to suppress it.<pre><code class=language-bash># filename prefix automatically added for multiple file arguments
$ rg -N 'say' ip.txt search.txt
search.txt
say

ip.txt
listen to what I say
$ rg -NI 'say' ip.txt search.txt
say

listen to what I say

# single file search
$ rg -N 'play' ip.txt
go play in the park
$ rg -NH 'play' ip.txt
ip.txt
go play in the park
</code></pre><p>Use the <code>--no-heading</code> option to get filename prefix for each matching line. This will also remove the newline separation between multiple files. When output is redirected, <code>--no-heading</code> option will be automatically active.<pre><code class=language-bash>$ rg -N --no-heading 'say' ip.txt search.txt
search.txt:say
ip.txt:listen to what I say

$ rg 'say' ip.txt search.txt | cat -
search.txt:say
ip.txt:listen to what I say

# add -I to suppress the filename prefix
$ rg -NI --no-heading 'say' ip.txt search.txt
say
listen to what I say
</code></pre><h3 id=field-separator><a class=header href=#field-separator>Field separator</a></h3><p>By default, <code>:</code> is used to separate prefixes like filename and line numbers. You can use the <code>--field-match-separator</code> option to customize this separator.<pre><code class=language-bash>$ rg --field-match-separator ')' 'the' ip.txt
3)go play in the park
4)come back before the sky turns dark
9)Try them all before you perish

$ rg --no-heading --field-match-separator ';' 'par' ip.txt pets.txt
pets.txt;2;I like parrots
ip.txt;3;go play in the park
</code></pre><h3 id=colored-output><a class=header href=#colored-output>Colored output</a></h3><p>The <code>--color</code> option works similar to the one seen earlier with <code>GNU grep</code>.<p>The <code>--colors</code> (note the plural form) option is useful to customize colors and style for matching text, line numbers, etc. A common usage is to highlight multiple terms in different colors. See manual for more details.<p align=center><img alt="rg colors customize"src=./images/rg_colors_customize.png><h3 id=context-matching><a class=header href=#context-matching>Context matching</a></h3><p>The options for context matching are very similar to <code>GNU grep</code>. The customization options are named differently: <code>--context-separator</code> and <code>--no-context-separator</code>. Also, escape sequences like <code>\t</code>, <code>\n</code>, etc can be used as part of the separator.<blockquote><p><img alt=info src=images/info.svg> Unlike <code>GNU grep</code>, using <code>0</code> as the context number will never add a separator in the output.</blockquote><pre><code class=language-bash>$ seq 29 | rg --context-separator '=====' -A1 '3'
3
4
=====
13
14
=====
23
24

$ seq 29 | rg --no-context-separator -A1 '3'
3
4
13
14
23
24
</code></pre><p>By default, <code>-</code> is used to separate the fields such as filename and line number prefix for context lines. You can use the <code>--field-context-separator</code> option to customize this separator.<pre><code class=language-bash>$ rg --no-heading -H -A1 'play' ip.txt
ip.txt:3:go play in the park
ip.txt-4-come back before the sky turns dark

$ rg --no-heading -H --field-context-separator ')' -A1 'play' ip.txt
ip.txt:3:go play in the park
ip.txt)4)come back before the sky turns dark
</code></pre><h3 id=scripting-options><a class=header href=#scripting-options>Scripting options</a></h3><p>You can use the <code>-q</code> option to suppress <code>stdout</code> and <code>--no-messages</code> to suppress <code>stderr</code>.<pre><code class=language-bash># when file doesn't exist
$ rg 'in' xyz.txt
xyz.txt: No such file or directory (os error 2)
$ rg --no-messages 'in' xyz.txt
$ echo $?
2

# some errors will require explicit redirection
$ rg --no-messages 'a(' ip.txt
regex parse error:
    a(
     ^
error: unclosed group
$ rg --no-messages 'a(' ip.txt 2> /dev/null
$ echo $?
2
</code></pre><h3 id=substitution><a class=header href=#substitution>Substitution</a></h3><p>The <code>-r</code> option will help you perform substitution operations. Here's an example:<pre><code class=language-bash># 'day' is the search pattern
# 'morning' is the replacement string
$ rg 'day' -r 'morning' ip.txt
1:it is a warm and cozy morning
</code></pre><p>Using <code>rg --passthru -N 'search' -r 'replace'</code> is very similar to how you can use the command <code>sed 's/search/replace/g'</code> for substitution. Some advantages with <code>ripgrep</code> include fixed string matching, recursive search (and speed benefit due to parallel processing), etc.<pre><code class=language-bash># replace 'and' with '&'
$ rg --passthru -N 'and' -r '&' ip.txt
it is a warm & cozy day
listen to what I say
go play in the park
come back before the sky turns dark

There are so many delights to cherish
Apple, Banana & Cherry
Bread, Butter & Jelly
Try them all before you perish
</code></pre><h3 id=multiline-matching><a class=header href=#multiline-matching>Multiline matching</a></h3><p>The <code>-U</code> option will allow you to match across multiple lines. Here's an example:<pre><code class=language-bash>$ rg -U 'y\ng' ip.txt
2:listen to what I say
3:go play in the park
</code></pre><blockquote><p><img alt=info src=images/info.svg> See my blog post <a href=https://learnbyexample.github.io/multiline-search-and-replace/>Multiline fixed string search and replace with CLI tools</a> for more examples with the <code>-U</code> option.</blockquote><h3 id=nul-separator><a class=header href=#nul-separator>NUL separator</a></h3><p>The <code>--null-data</code> option helps to process data that use the ASCII NUL character as the separator.<pre><code class=language-bash>$ printf 'cred\nteal\0a2\0spared' | rg --null-data 'red' | sed 's/\x0/\n---\n/g'
cred
teal
---
spared
---
</code></pre><h2 id=ripgrep-regex><a class=header href=#ripgrep-regex>ripgrep regex</a></h2><p>From <a href=https://docs.rs/regex/latest/regex/>regex crate</a>:<blockquote><p>Its syntax is similar to Perl-style regular expressions, but lacks a few features like look around and backreferences. In exchange, all searches execute in linear time with respect to the size of the regular expression and search text.</blockquote><p>By default, <code>rg</code> treats the search term as a regular expression. You can use the following options to alter the default behavior:<ul><li><code>-F</code> option will cause the search patterns to be treated literally<li><code>-P</code> option will enable Perl Compatible Regular Expression (PCRE) instead of regex crate<li><code>--engine=auto</code> option will dynamically use PCRE when needed</ul><p>This section will cover syntax and features that are different from the BRE/ERE flavor seen earlier. PCRE will be discussed later in a separate section.<h3 id=string-vs-line-anchors><a class=header href=#string-vs-line-anchors>String vs line anchors</a></h3><p><code>\A</code> restricts the match to the start of string and <code>\z</code> restricts the match to the end of string. You'll also need the <code>-U</code> multiline option to use string anchors.<pre><code class=language-bash># start of the line vs start of the string
$ printf 'hi-hello\ntop-spot\n' | rg -o '^\w+'
hi
top
$ printf 'hi-hello\ntop-spot\n' | rg -Uo '\A\w+'
hi

# end of the line vs end of the string
$ printf 'hi-hello\ntop-spot\n' | rg -o '\w+$'
hello
spot
# note that you need to match \n as well (if present) for \z
$ printf 'hi-hello\ntop-spot\n' | rg -Uo '\w+\n\z'
spot
</code></pre><h3 id=alternation-precedence><a class=header href=#alternation-precedence>Alternation precedence</a></h3><p>The alternative which matches earliest in the input gets higher precedence. Left-to-right precedence if there are alternatives that match from the same starting index.<pre><code class=language-bash># alternative which matches earliest gets higher precedence
$ echo 'best years' | rg 'year|years' -r 'X'
best Xs
$ echo 'best years' | rg 'years|year' -r 'X'
best X

# left to right precedence if alternatives match from the same index
$ printf 'spared PARTY PaReNt' | rg -io 'par|pare|spare'
spare
PAR
PaR

# workaround is to sort alternations based on length, longest first
$ printf 'spared PARTY PaReNt' | rg -io 'spare|pare|par'
spare
PAR
PaRe
</code></pre><h3 id=the-dot-metacharacter><a class=header href=#the-dot-metacharacter>The dot metacharacter</a></h3><p>The dot metacharacter matches any character except newline. You can set the <code>s</code> modifier to enable <code>.</code> to match the newline character as well. Modifiers will be discussed in more detail later.<pre><code class=language-bash># here '.' will not match newline characters
$ printf 'blue green\nteal brown' | rg -Uo 'g.*n'
green

$ printf 'blue green\nteal brown' | rg -Uo '(?s)g.*n'
green
teal brown
</code></pre><h3 id=greedy-quantifiers><a class=header href=#greedy-quantifiers>Greedy Quantifiers</a></h3><p>The <code>*</code>, <code>+</code>, <code>?</code> and <code>{m,n}</code> quantifiers are similar to those in BRE/ERE but there are a few differences too. The <code>{m,n}</code> quantifiers can include whitespace characters inside <code>{}</code>. Also, the <code>{,n}</code> version isn't allowed.<pre><code class=language-bash>$ echo 'abc ac adc abbc xabbbcz bbb bc abbbbbc' | rg -o 'ab{1, 4}c'
abc
abbc
abbbc

$ echo 'abc ac adc abbc xabbbcz bbb bc abbbbbc' | rg -o 'ab{,4}c'
regex parse error:
    ab{,4}c
       ^
error: repetition quantifier expects a valid decimal
</code></pre><p>Greedy quantifiers will try to match as much as possible and give back characters if it can help match the overall pattern, which is similar to the behavior in BRE/ERE. One key difference is that precedence is left-to-right instead of longest match wins.<pre><code class=language-bash>$ echo 'fig123312apple' | rg -o 'g[123]+(12apple)?'
g123312
</code></pre><h3 id=non-greedy-quantifiers><a class=header href=#non-greedy-quantifiers>Non-greedy quantifiers</a></h3><p>These quantifiers will try to match as minimally as possible. Appending a <code>?</code> to greedy quantifiers makes them non-greedy.<pre><code class=language-bash>$ echo 'foot' | rg 'f.??o' -r 'X'
Xot

# overall pattern has to be satisfied as well
$ echo 'frost' | rg 'f.??o' -r 'X'
Xst
</code></pre><h3 id=character-classes><a class=header href=#character-classes>Character classes</a></h3><p>In addition to <code>\w</code>, <code>\s</code> and their opposites, you can also use <code>\d</code> to match digit characters. Use <code>\D</code> for non-digit characters. Also, these escapes can be used inside <code>[]</code> too.<pre><code class=language-bash>$ echo 'Sample123string42with777numbers' | rg '\d+' -r ':'
Sample:string:with:numbers

$ echo 'Sample123string42with777numbers' | rg '\D+' -r ':'
:123:42:777:

$ echo 'tea sea-(pit sit);lean bean' | rg -o '[\w\s]+'
tea sea
pit sit
lean bean
</code></pre><p><a href=./breere-regular-expressions.html#named-character-sets>Named character sets</a> are supported as well. One additional feature is that you can use <code>[:^name:]</code> to negate that particular set alone.<pre><code class=language-bash># delete all non-punctuation characters as well as the '*' character
$ echo "Hi. How *are* you?" | rg '[[:^punct:]*]+' -r ''
.?
</code></pre><p>Character class metacharacters can be matched literally by specific placement or by using <code>\</code> to escape them. These are all similar to those seen in BRE/ERE, except that <code>[</code> has to be always escaped for a literal match.<h3 id=set-operations><a class=header href=#set-operations>Set operations</a></h3><p>These operators can be applied inside character class between sets. Mostly used to get intersection or difference between two sets, where one/both of them is a character range or a predefined character set. To aid in such definitions, you can use <code>[]</code> in nested fashion.<pre><code class=language-bash># intersection of lowercase alphabets and non-vowel characters
# can also use set difference: rg -ow '[a-z--aeiou]+'
$ echo 'tryst glyph pity why' | rg -ow '[a-z&&[^aeiou]]+'
tryst
glyph
why

# symmetric difference, [[a-l]~~[g-z]] is same as [a-fm-z]
$ echo 'gets eat top sigh' | rg -ow '[[a-l]~~[g-z]]+'
eat
top

# remove all punctuation characters except . ! and ?
$ para='"Hi", there! How *are* you? All fine here.'
$ echo "$para" | rg '[[:punct:]--[.!?]]+' -r ''
Hi there! How are you? All fine here.
</code></pre><h3 id=backreferences><a class=header href=#backreferences>Backreferences</a></h3><p>The syntax is <code>$N</code> where <code>N</code> is the capture group you want. Leftmost <code>(</code> in the regular expression is <code>$1</code>, next one is <code>$2</code> and so on. By default, <code>$0</code> will give entire matched portion. Use <code>${N}</code> to avoid ambiguity between backreference and other characters.<pre><code class=language-bash># remove square brackets that surround digit characters
$ echo '[52] apples [and] [31] mangoes' | rg '\[(\d+)]' -r '$1'
52 apples [and] 31 mangoes

# add something around the matched strings
$ echo '52 apples and 31 mangoes' | rg '\d+' -r '(${0}4)'
(524) apples and (314) mangoes
</code></pre><p>Use <code>$$</code> to represent <code>$</code> literally in the replacement section. This is only needed for ambiguous cases.<pre><code class=language-bash>$ echo 'a b a' | rg 'a' -r '$$x'
$x b $x

$ echo 'a b a' | rg 'a' -r '$${a}'
${a} b ${a}

# no ambiguity here, so $$ not needed
$ echo '100' | rg '^' -r '$'
$100
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> Backreferences aren't allowed in the search pattern. Use PCRE flavor if needed.<pre><code class=language-bash>$ echo 'fort effort' | rg -ow '\w*(\w)\1\w*'
regex parse error:
    \w*(\w)\1\w*
           ^^
error: backreferences are not supported

Consider enabling PCRE2 with the --pcre2 flag, which can handle backreferences
and look-around.
</code></pre></blockquote><h3 id=non-capturing-groups><a class=header href=#non-capturing-groups>Non-capturing groups</a></h3><p>You can use non-capturing groups <code>(?:pattern)</code> to avoid keeping a track of groups not needed for backreferencing.<pre><code class=language-bash># the first group is needed to apply quantifier, not backreferencing
$ echo '1,2,3,4,5,6,7' | rg '^(([^,]+,){3})([^,]+)' -r '$1($3)'
1,2,3,(4),5,6,7

# you can use non-capturing groups in such cases
$ echo '1,2,3,4,5,6,7' | rg '^((?:[^,]+,){3})([^,]+)' -r '$1($2)'
1,2,3,(4),5,6,7
</code></pre><h3 id=named-capture-groups><a class=header href=#named-capture-groups>Named capture groups</a></h3><p>The syntax is <code>(?P&LTname>pattern)</code> to define a named capture group, useful for readability purposes. Use <code>$name</code> to backreference such groups (<code>$N</code> can also be used). Use <code>${name}</code> to avoid ambiguity between backreference and other characters.<pre><code class=language-bash>$ echo 'good,bad 42,24' | rg '(?P&LTfw>\w+),(?P&LTsw>\w+)' -r '$sw,$fw'
bad,good 24,42

$ row='today,2008-24-03,food,2012-12-08,nice,5632'
$ echo "$row" | rg '(?P&LTdd>-\d{2})(?P&LTmm>-\d{2})' -r '$mm$dd'
today,2008-03-24,food,2012-08-12,nice,5632
</code></pre><h3 id=extract-matches-with-surrounding-conditions><a class=header href=#extract-matches-with-surrounding-conditions>Extract matches with surrounding conditions</a></h3><p>Using backreferences in combination with <code>-o</code> and <code>-r</code> options will allow to extract matches that should also satisfy some surrounding conditions.<pre><code class=language-bash># extract digits that follow =
$ echo 'apple=42, fig=314, banana:512' | rg -o '=(\d+)' -r '$1'
42
314

# extract digits only if it is preceded by - and followed by ; or :
$ echo '42 apple-5, fig3; x-83, y-20: f12' | rg -o '\-(\d+)[:;]' -r '$1'
20

$ s='cat scatter cater scat concatenate catastrophic catapult duplicate'
# extract 3rd occurrence of 'cat' followed by optional lowercase letters
$ echo "$s" | rg -o '^(?:.*?cat.*?){2}(cat[a-z]*)' -r '$1'
cater
# extract occurrences at multiples of 3
$ echo "$s" | rg -o '(?:.*?cat.*?){2}(cat[a-z]*)' -r '$1'
cater
catastrophic
</code></pre><h3 id=modifiers><a class=header href=#modifiers>Modifiers</a></h3><div class=table-wrapper><table><thead><tr><th>Modifier<th>Description<tbody><tr><td><code>i</code><td>case sensitivity<tr><td><code>m</code><td>multiline for line anchors (enabled by default for <code>-U</code> option)<tr><td><code>s</code><td>matching newline with <code>.</code> metacharacter<tr><td><code>x</code><td>readable pattern with whitespace and comments<tr><td><code>u</code><td>unicode</table></div><p>To apply modifiers selectively, specify them inside a special grouping syntax. This will override the modifiers applied to entire pattern, if any. The syntax variations are:<ul><li><code>(?modifiers:pattern)</code> will apply modifiers only for this portion<li><code>(?-modifiers:pattern)</code> will negate modifiers only for this portion<li><code>(?modifiers-modifiers:pattern)</code> will apply and negate particular modifiers only for this portion<li><code>(?modifiers)</code> when pattern is not given, modifiers (including negation) will be applied from this point onwards</ul><pre><code class=language-bash># same as: rg -i 'cat' -r '[$0]'
$ echo 'Cat cOnCaT scatter cut' | rg '(?i)cat' -r '[$0]'
[Cat] cOn[CaT] s[cat]ter cut
# override -i option
$ printf 'Cat\ncOnCaT\nscatter\ncut' | rg -i '(?-i)cat'
scatter
# same as: rg -i '(?-i:Cat)[a-z]*\b' or rg 'Cat(?i)[a-z]*\b'
$ echo 'Cat SCatTeR CATER cAts' | rg 'Cat(?i:[a-z]*)\b' -r '[$0]'
[Cat] S[CatTeR] CATER cAts

# multiple modifiers can be used together
# 'm' is on by default for -U option
$ printf 'Cat\ncOnCaT\nscatter\nCater' | rg -Uo '(?is)on.*^cat'
OnCaT
scatter
Cat
</code></pre><p>The <code>x</code> modifier allows you to use literal unescaped whitespaces for readability purposes and add comments after an unescaped <code>#</code> character.<pre><code class=language-bash>$ echo 'fox,cat,dog,parrot' | rg -o '(?x) ( ,[^,]+ ){2}$ #last 2 columns'
,dog,parrot

# need to escape whitespaces or use them inside [] to match literally
$ echo 'a cat and a dog' | rg '(?x)t a'
$ echo 'a cat and a dog' | rg '(?x)t\ a'
a cat and a dog

$ echo 'foo a#b 123' | rg -o '(?x)a#.'
a
$ echo 'foo a#b 123' | rg -o '(?x)a\#.'
a#b
</code></pre><h3 id=unicode><a class=header href=#unicode>Unicode</a></h3><p>Similar to named character classes and escapes, the <code>\p{}</code> construct offers various predefined sets to work with Unicode strings. See <a href=https://www.regular-expressions.info/unicode.html>regular-expressions: Unicode</a> for more details. See <code>-E</code> option regarding encoding support.<pre><code class=language-bash># all consecutive letters
# note that {} can be omitted for single characters
$ echo 'fox:αλεπού,eagle:αετός' | rg '\p{L}+' -r '($0)'
(fox):(αλεπού),(eagle):(αετός)

# extract all consecutive Greek letters
$ echo 'fox:αλεπού,eagle:αετός' | rg -o '\p{Greek}+'
αλεπού
αετός

# escapes like \d, \w, \s are unicode aware
$ echo 'φοο12,βτ_4,bat' | rg '\w+' -r '[$0]'
[φοο12],[βτ_4],[bat]
# can be disabled by using the 'u' modifier
$ echo 'φοο12,βτ_4,bat' | rg '(?-u)\w+' -r '[$0]'
φοο[12],βτ[_4],[bat]

# extract all characters other than letters, \PL can also be used
$ echo 'φοο12,βτ_4,bat' | rg -o '\P{L}+'
12,
_4,
</code></pre><p>Characters can be specified in the hexadecimal <code>\x{}</code> format as well.<pre><code class=language-bash># {} are optional if only two hexadecimal characters are needed
$ echo 'a cat and a dog' | rg 't\x20a'
a cat and a dog

$ echo 'fox:αλεπού,eagle:αετός' | rg -o '[\x61-\x7a]+'
fox
eagle

$ echo 'fox:αλεπού,eagle:αετός' | rg -o '[\x{3b1}-\x{3bb}]+'
αλε
αε
</code></pre><h2 id=perl-compatible-regular-expressions><a class=header href=#perl-compatible-regular-expressions>Perl Compatible Regular Expressions</a></h2><p>Use <code>-P</code> option to enable Perl Compatible Regular Expressions (PCRE) instead of the default regex. Both <code>GNU grep</code> and <code>ripgrep</code> use the PCRE2 version of the library, so most of the pattern matching features will work the same way.<p>One significant difference is that <code>ripgrep</code> provides substitution via the <code>-r</code> option. And there are a few subtle differences, like the <code>-f</code> and <code>-e</code> options, empty matches, etc.<pre><code class=language-bash># empty match handling
$ echo '1a42z' | grep -oP '[a-z]*'
a
z
$ echo '1a42z' | rg -oP '[a-z]*'

a

z

$ printf 'sub\nbit' | grep -P -f- five_words.txt
grep: the -P option only supports a single pattern
$ printf 'sub\nbit' | rg -P -f- five_words.txt
2:subtle
4:exhibit

$ grep -P -e 'sub' -e 'bit' five_words.txt
grep: the -P option only supports a single pattern
$ rg -P -e 'sub' -e 'bit' five_words.txt
2:subtle
4:exhibit
</code></pre><p>Here are some examples where you might need the <code>-P</code> option over the default regex features. See the <a href=./perl-compatible-regular-expressions.html#perl-compatible-regular-expressions>Perl Compatible Regular Expressions</a> chapter for more examples.<pre><code class=language-bash># lookarounds is a major feature not supported by the regex crate
# words containing all lowercase vowels in any order
$ rg -NP '(?=.*a)(?=.*e)(?=.*i)(?=.*o).*u' five_words.txt
sequoia
questionable
equation

# same as: rg -o '^(?:.*?cat.*?){2}(cat[a-z]*)' -r '$1'
$ s='cat scatter cater scat concatenate catastrophic catapult duplicate'
$ echo "$s" | rg -oP '^(.*?cat.*?){2}\Kcat[a-z]*'
cater

# match if 'go' is not there between 'at' and 'par'
$ echo 'fox,cat,dog,parrot' | rg -qP 'at((?!go).)*par' && echo 'match found'
match found

# backreference in the search pattern
# remove any number of consecutive duplicate words that are separated by a space
$ echo 'aa a a a 42 f_1 f_1 f_13.14' | rg -P '\b(\w+)( \1)+\b' -r '$1'
aa a 42 f_1 f_13.14

# mix regex and literal matching
$ expr='(a^b)'
$ echo 'f*(2-a/b) - 3*(a^b)-42' | rg -oP '\S*\Q'"$expr"'\E\S*'
3*(a^b)-42
</code></pre><p>If you wish to use default regex and switch to PCRE when needed, use the <code>--engine=auto</code> option.<pre><code class=language-bash># using a feature not present normally
$ echo '123-87-593 42 apple-12-345' | rg -o '\G\d+-?'
regex parse error:
    \G\d+-?
    ^^
error: unrecognized escape sequence

# automatically switch to PCRE
# all digits and optional hyphen combo from the start of string
$ echo '123-87-593 42 apple-12-345' | rg -o --engine=auto '\G\d+-?'
123-
87-
593
</code></pre><blockquote><p><img alt=info src=images/info.svg> See my blog post <a href=https://learnbyexample.github.io/substitution-with-ripgrep/>Search and replace tricks with ripgrep</a> for more examples.</blockquote><h2 id=recursive-search><a class=header href=#recursive-search>Recursive search</a></h2><p>This section will discuss the recursive features provided by <code>ripgrep</code> and related options.<h3 id=sample-directory><a class=header href=#sample-directory>Sample directory</a></h3><p>For sample files and directories used in this section, go to the <code>example_files</code> directory and source the <code>grep.sh</code> script.<pre><code class=language-bash>$ source grep.sh

$ tree -a
.
├── backups
│   ├── color list.txt
│   └── dot_files
│       ├── .bash_aliases
│       └── .inputrc
├── colors_1
├── colors_2
├── .hidden
└── projects
    ├── dot_files -> ../backups/dot_files
    ├── python
    │   └── hello.py
    └── shell
        └── hello.sh

6 directories, 8 files
</code></pre><h3 id=default-behavior><a class=header href=#default-behavior>Default behavior</a></h3><p>As mentioned earlier, <code>ripgrep</code> will search the current working directory recursively if no path is given. Here's an example:<pre><code class=language-bash>$ rg 'blue'
backups/color list.txt
3:blue

colors_2
1:blue

colors_1
2:light blue
</code></pre><p>Some files will not be searched by default. These are files matched by rules specified by ignore files (such as <code>.gitignore</code>), hidden files and binary files. Symbolic links found while traversing a directory are also ignored by default. You can use the <code>--files</code> option to list the files that would be searched:<pre><code class=language-bash># in this example, only the hidden files are absent
# there are no ignore or binary files
# you can use 'find -type f' to get the full list of files
$ rg --files
backups/color list.txt
colors_2
colors_1
projects/shell/hello.sh
projects/python/hello.py
</code></pre><p>Here's an example of passing files and directories as arguments. In this case, the current directory won't be searched.<pre><code class=language-bash>$ rg --files projects colors_1
colors_1
projects/shell/hello.sh
projects/python/hello.py
</code></pre><h3 id=ignore-files><a class=header href=#ignore-files>Ignore files</a></h3><p>The presence of a <code>.git</code> directory (current or parent directories) would mark <code>.gitignore</code> to be used for ignoring. You can use the <code>--no-require-git</code> option to enable such ignore rules even for a non-git directory. For illustration purposes, an empty <code>.git</code> directory would be created here instead of an actual <code>git</code> project. In addition to <code>.gitignore</code>, filenames like <code>.ignore</code> and <code>.rgignore</code> are also used for determining files to ignore. For more details, refer to the manual as well as the <a href=https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md>ripgrep: user guide</a>. Here's an example to show <code>.gitignore</code> in action:<pre><code class=language-bash>$ mkdir .git
$ echo 'color*' > .gitignore
$ rg --files
projects/shell/hello.sh
projects/python/hello.py
</code></pre><p>You can use the <code>--no-ignore</code> option to disable the default pruning of ignore files.<pre><code class=language-bash>$ rg --no-ignore --files
backups/color list.txt
colors_2
colors_1
projects/shell/hello.sh
projects/python/hello.py
</code></pre><p>Delete the <code>.git</code> folder and <code>.gitignore</code> file as they will hinder examples to be presented next.<pre><code class=language-bash>$ rm -r .git .gitignore
</code></pre><h3 id=hidden-files><a class=header href=#hidden-files>Hidden files</a></h3><p>Use the <code>--hidden</code> or <code>-.</code> option to search hidden files as well.<pre><code class=language-bash>$ rg -l 'blue'
backups/color list.txt
colors_2
colors_1

# same as: rg -. -l 'blue'
$ rg --hidden -l 'blue'
backups/color list.txt
colors_2
colors_1
.hidden
</code></pre><h3 id=-u-option><a class=header href=#-u-option>-u option</a></h3><p>As a shortcut, you can use:<ul><li><code>-u</code> to indicate <code>--no-ignore</code><li><code>-uu</code> to indicate <code>--no-ignore --hidden</code><li><code>-uuu</code> to indicate <code>--no-ignore --hidden --binary</code></ul><p>With <code>rg -uuu</code> you can match the default behavior of the <code>grep -r</code> command.<h3 id=follow-links><a class=header href=#follow-links>Follow links</a></h3><p>Use the <code>-L</code> option to search symbolic links that are found while traversing a directory. Here's an example:<pre><code class=language-bash>$ rg --hidden -l 'pwd'
backups/dot_files/.bash_aliases

# dot_files is a symbolic link
$ stat -c '%N' projects/dot_files
'projects/dot_files' -> '../backups/dot_files'

# -L option enables searching symbolic links
$ rg --hidden -lL 'pwd'
projects/dot_files/.bash_aliases
backups/dot_files/.bash_aliases
</code></pre><h3 id=nul-separator-for-filenames><a class=header href=#nul-separator-for-filenames>NUL separator for filenames</a></h3><p>The <code>-0</code> option will use the ASCII NUL character as the separator for file paths in the output. This is helpful to avoid issues due to shell metacharacters in the filenames.<pre><code class=language-bash># error due to 'backups/color list.txt' having a shell metacharacter
$ rg -l 'blue' | xargs rg -l 'teal'
backups/color: No such file or directory (os error 2)
list.txt: No such file or directory (os error 2)
colors_1

# NUL separator to the rescue
$ rg -l0 'blue' | xargs -r0 rg -l 'teal'
colors_1
</code></pre><h3 id=predefined-file-types><a class=header href=#predefined-file-types>Predefined file types</a></h3><p>The <code>-t</code> option provides a handy way to search files based on their extension. Use <code>rg --type-list</code> to see all the available types and their glob patterns.<pre><code class=language-bash># both 'md' and 'markdown' match the same file types
$ rg --type-list | rg 'markdown'
markdown: *.markdown, *.md, *.mdown, *.mkdn
md: *.markdown, *.md, *.mdown, *.mkdn

$ rg --type-list | rg '^c:'
c: *.[chH], *.[chH].in, *.cats
</code></pre><p>Here are some examples featuring the <code>-t</code> option:<pre><code class=language-bash># python and shell files
$ rg -t 'py' -t 'sh' --files
projects/shell/hello.sh
projects/python/hello.py

# files ending with .txt
$ rg -t 'txt' --files
backups/color list.txt
</code></pre><p>You can use the <code>-T</code> option to invert the selection.<pre><code class=language-bash># other than files ending with .txt
$ rg -T 'txt' --files
colors_2
colors_1
projects/shell/hello.sh
projects/python/hello.py
</code></pre><h3 id=glob-pattern-matching><a class=header href=#glob-pattern-matching>Glob pattern matching</a></h3><p>The <code>-t</code> option helps you search based on already defined types. The <code>-g</code> option allows you to define your own glob pattern for matching the filenames. If <code>/</code> is not present in the glob provided, files will be matched against the basename only, not the entire path.<pre><code class=language-bash># files ending with '.sh' or '.py'
$ rg -g '*.{sh,py}' --files
projects/shell/hello.sh
projects/python/hello.py

# files having 'color' in their name
$ rg -g '*color*' --files
backups/color list.txt
colors_2
colors_1
</code></pre><p>Using <code>!</code> as the first character in the glob pattern will negate the matching. For example, <code>-g '!*.py'</code> will match other than files ending with <code>.py</code>.<pre><code class=language-bash># files not having 'color' in their name
$ rg -g '!*color*' --files
projects/shell/hello.sh
projects/python/hello.py
</code></pre><p>You can apply file type and glob based matching multiple times:<pre><code class=language-bash>$ rg -g '*color*' -g '!*1*' --files
backups/color list.txt
colors_2

$ rg -T 'txt' -g '!*.sh' --files
colors_2
colors_1
projects/python/hello.py
</code></pre><p>The <code>-g</code> option uses the <code>.gitignore</code> rules for pattern matching (which differs from shell globbing rules). See <a href=https://git-scm.com/docs/gitignore#_pattern_format>git documentation: gitignore pattern format</a> for more details. The <code>**</code> pattern serves as a placeholder for zero or more levels of directories.<pre><code class=language-bash># path (not just basename) containing 'b' or 'y'
$ rg -g '**/*[by]*/**' --files
backups/color list.txt
backups/dot_files/.inputrc
backups/dot_files/.bash_aliases
projects/python/hello.py

# * instead of ** will match only a single level
$ rg -g '*/*[by]*/**' --files
projects/python/hello.py
$ rg -g '**/*[by]*/*' --files
backups/color list.txt
projects/python/hello.py
</code></pre><blockquote><p><img alt=info src=images/info.svg> Use the <code>-iglob</code> option to match filenames case insensitively.</blockquote><h3 id=limit-traversal-levels><a class=header href=#limit-traversal-levels>Limit traversal levels</a></h3><p>The <code>--max-depth</code> option will help you limit the recursion depth. For example, with <code>1</code> as the value, the search won't descend into sub-directories.<pre><code class=language-bash># exclude all sub-directories
# same as: rg -g '!*/' --files
$ rg --max-depth 1 --files
colors_2
colors_1
</code></pre><h3 id=debug-and-other-options><a class=header href=#debug-and-other-options>Debug and other options</a></h3><p>The <code>--debug</code> and <code>--trace</code> (more detailed debug) options can be used for debugging purposes, for example to know why a file is being ignored.<p>There are many more options to customize the search experience. For example, the <code>--type-add</code> option allows you to define your own type, the <code>--max-depth</code> option controls the depth of traversal and so on.<p>See <a href=https://github.com/BurntSushi/ripgrep/blob/master/GUIDE.md#configuration-file>ripgrep user guide: configuration</a> for examples and details on how to maintain them in a file.<h2 id=speed-comparison><a class=header href=#speed-comparison>Speed comparison</a></h2><p><code>ripgrep</code> automatically makes use of parallel resources to provide quicker results. <code>GNU grep</code> would need external tools like <code>xargs</code> and <code>parallel</code> for such cases.<p>A sample comparison is shown below using the directory that was previously mentioned in the <a href=./gotchas-and-tricks.html#parallel-execution>Parallel execution</a> section.<pre><code class=language-bash># assumes 'linux-4.19' as the current working directory
# my machine can run four processes in parallel

$ time grep -rw 'user' > ../f1
real    0m0.886s
$ time rg -uuu -w 'user' > ../f2
real    0m0.287s

$ diff -sq <(sort ../f1) <(sort ../f2)
Files /dev/fd/63 and /dev/fd/62 are identical

# clean up
$ rm ../f[12]
</code></pre><p>Lot of factors like file size, file encoding, line size, sparse or dense matches, hardware features, etc will affect the performance. <code>ripgrep</code> provides options like <code>-j</code>, <code>--dfa-size-limit</code> and <code>--mmap</code> for tuning performance related settings.<blockquote><p><img alt=info src=images/info.svg> See <a href=https://blog.burntsushi.net/ripgrep/>Benchmark with other grep implementations</a> by the author of <code>ripgrep</code> command for a methodological analysis and insights.</blockquote><h2 id=ripgrep-all><a class=header href=#ripgrep-all>ripgrep-all</a></h2><p>Quoting from the <a href=https://github.com/phiresky/ripgrep-all>GitHub repo</a>:<blockquote><p><code>rga</code> is a line-oriented search tool that allows you to look for a regex in a multitude of file types. <code>rga</code> wraps the awesome <code>ripgrep</code> and enables it to search in pdf, docx, sqlite, jpg, movie subtitles (mkv, mp4), etc.</blockquote><p>The main attraction is pairing file types and relevant tools to enable text searching. <code>rga</code> also has a handy caching feature that speeds up the search for subsequent usages on the same input.<h2 id=summary><a class=header href=#summary>Summary</a></h2><p><code>ripgrep</code> is an excellent alternative to <code>GNU grep</code>. If you are working with large code bases, I'd definitely recommend <code>ripgrep</code> for its performance and customization options. There are interesting features in the pipeline too, for example <a href=https://github.com/BurntSushi/ripgrep/issues/1497>ngram indexing support</a>.<h2 id=exercises><a class=header href=#exercises>Exercises</a></h2><p>Would be a good idea to first redo all the exercises using <code>rg</code> from all the previous chapters. Some exercises will require reading the manual, as those options aren't covered in this book.<blockquote><p><img alt=info src=images/info.svg> The <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep/tree/master/exercises>exercises</a> directory has all the files used in this section.</blockquote><p><strong>1)</strong> Which option will change the line separator from <code>\n</code> to <code>\r\n</code>?<pre><code class=language-bash># no output
$ rg -cx '' dos.txt

##### add your solution here
4
</code></pre><p><strong>2)</strong> Default behavior of <code>ripgrep</code> changes depending on whether the output is redirected or not. Use appropriate option(s) to filter lines containing <code>are</code> from the <code>sample.txt</code> and <code>patterns.txt</code> input files and pipe the output to <code>tr 'a-z' 'A-Z'</code> to get results as shown below.<pre><code class=language-bash>##### add your solution here
PATTERNS.TXT
12:CARE
15:SCARE

SAMPLE.TXT
4:HOW ARE YOU
</code></pre><p><strong>3)</strong> Replace all occurrences of <code>].*[</code> with <code>_</code> for the input file <code>regex_terms.txt</code>.<pre><code class=language-bash>##### add your solution here
^[c-k].*\W$
ly.
[A-Z_0-9]
</code></pre><p><strong>4)</strong> For the input file <code>nul_separated</code>, use the ASCII NUL character as the <em>line</em> separator and display lines containing <code>fig</code>. Perform additional transformation to convert ASCII NUL characters, if any, to the newline character.<pre><code class=language-bash>##### add your solution here
apple
fig
mango
icecream
</code></pre><p><strong>5)</strong> For the input file <code>nul_separated</code>, replace the ASCII NUL character with a newline character, followed by <code>---</code> and another newline character.<pre><code class=language-bash>##### add your solution here
apple
fig
mango
icecream
---
how are you
have a nice day
---
dragon unicorn centaur
</code></pre><p><strong>6)</strong> Extract all whole words from the <code>sample.txt</code> input file. However, do not extract words if they contain any character present in the <code>ignore</code> shell variable.<pre><code class=language-bash>$ ignore='aety'
##### add your solution here
World
Hi
How
do
Much
Adios

$ ignore='eosW'
##### add your solution here
Hi
it
it
banana
papaya
Much
</code></pre><p><strong>7)</strong> How would you represent a <code>$</code> character literally when using the <code>-r</code> option?<p><strong>8)</strong> From the <code>patterns.txt</code> input file, extract from <code>car</code> at the start of a line to the very next occurrence of <code>book</code> or <code>lie</code> in the file.<pre><code class=language-bash>##### add your solution here
care
4*5]
a huge discarded pile of book
car
eden
rested replie
</code></pre><p><strong>9)</strong> From the <code>pcre.txt</code> input file, extract from the second field to the second last field from rows having at least two columns considering <code>;</code> as the delimiter. For example, <code>b;c</code> should be extracted from <code>a;b;c;d</code> and a line containing less than two <code>;</code> characters shouldn't produce any output.<pre><code class=language-bash>##### add your solution here
in;awe;b2b;3list
be;he;0;a;b
</code></pre><p><strong>10)</strong> For the input file <code>python.md</code>, match all lines containing <code>python</code> irrespective of case, but not if it is part of code blocks that are bounded by triple backticks.<pre><code class=language-bash>##### add your solution here
REPL is a good way to learn PYTHON for beginners.
python comes loaded with awesome methods. Enjoy learning pYtHoN.
</code></pre><blockquote><p><img alt=info src=images/info.svg> For the rest of the exercises, use the <code>recursive_matching</code> directory that was created in an earlier chapter. Source the <code>recursive.sh</code> script if you haven't created this directory yet.<pre><code class=language-bash># the 'recursive.sh' script is present in the 'exercises' directory
$ source recursive.sh
</code></pre></blockquote><p><strong>11)</strong> List all files not containing <code>blue</code>. Hidden files should also be considered.<pre><code class=language-bash>##### add your solution here
substitute.sh
backups/dot_files/.bash_aliases
backups/dot_files/.inputrc
projects/shell/hello.sh
projects/python/hello.py
</code></pre><p><strong>12)</strong> List all the files in the <code>backups</code> directory, including links and hidden files.<pre><code class=language-bash>##### add your solution here
backups/text/pat.txt
backups/color list.txt
backups/dot_files/.inputrc
backups/dot_files/.bash_aliases
</code></pre><p><strong>13)</strong> What does the <code>-uuu</code> option mean?<p><strong>14)</strong> Display lines containing a word ending with <code>e</code>. Search only among the <code>sh</code> file type and the output should not have line number or filename prefixes.<pre><code class=language-bash>##### add your solution here
sed -i 's/search/replace/g' **/*.txt
</code></pre><p><strong>15)</strong> List files other than hidden files and file types <code>sh</code> and <code>py</code>. Links should be considered for listing.<pre><code class=language-bash>##### add your solution here
backups/text/pat.txt
backups/color list.txt
colors_2.txt
sample_file.txt
colors_1
</code></pre><p><strong>16)</strong> List all files not containing a <code>.</code> character in their names. Ignore links.<pre><code class=language-bash>##### add your solution here
colors_1
</code></pre><p><strong>17)</strong> What does <code>**</code> mean when used with the <code>-g</code> option?<p><strong>18)</strong> Search recursively and list the names of files that contain <code>Hello</code> or <code>blue</code>. Symbolic links should be searched as well. Do not search within <code>python</code> or <code>backups</code> directories.<pre><code class=language-bash>##### add your solution here
colors_2.txt
sample_file.txt
colors_1
projects/shell/hello.sh
</code></pre><p><strong>19)</strong> Match lines containing <code>Hello</code> or <code>red</code> only from files in the current hierarchy, i.e. don't search recursively. Symbolic links should be searched as well.<pre><code class=language-bash>##### add your solution here
colors_2.txt
5:red

sample_file.txt
1:Hello World
</code></pre><p><strong>20)</strong> Search recursively for files containing <code>blue</code>, <code>yellow</code> and <code>teal</code> anywhere in the file.<pre><code class=language-bash>##### add your solution here
colors_1
</code></pre></main><nav aria-label="Page navigation"class=nav-wrapper><a aria-label="Previous chapter"class="mobile-nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=gotchas-and-tricks.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="mobile-nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=further-reading.html rel=next> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav aria-label="Page navigation"class=nav-wide-wrapper><a aria-label="Previous chapter"class="nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=gotchas-and-tricks.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=further-reading.html rel=next> <i class="fa fa-angle-right"></i> </a></nav></div><script>window.playground_copyable = true;</script><script charset=utf-8 src=elasticlunr.min.js></script><script charset=utf-8 src=mark.min.js></script><script charset=utf-8 src=searcher.js></script><script charset=utf-8 src=clipboard.min.js></script><script charset=utf-8 src=highlight.js></script><script charset=utf-8 src=book.js></script><script src=sidebar.js></script>