<!doctypehtml><html class="sidebar-visible no-js light"lang=en><head><meta charset=UTF-8><title>Frequently used options - CLI text processing with GNU grep and ripgrep</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta content="Example based guide to mastering GNU grep and ripgrep"name=description><meta content=width=device-width,initial-scale=1 name=viewport><meta content=#ffffff name=theme-color><meta content="CLI text processing with GNU grep and ripgrep"property=og:title><meta content=website property=og:type><meta content="Example based guide to mastering GNU grep and ripgrep"property=og:description><meta content=https://learnbyexample.github.io/learn_gnugrep_ripgrep/ property=og:url><meta content=https://raw.githubusercontent.com/learnbyexample/learn_gnugrep_ripgrep/master/images/grep_ls.png property=og:image><meta content=1280 property=og:image:width><meta content=720 property=og:image:height><meta content=summary_large_image property=twitter:card><meta content=@learn_byexample property=twitter:site><link href=favicon.svg rel=icon><link rel="shortcut icon"href=favicon.png><link href=css/variables.css rel=stylesheet><link href=css/general.css rel=stylesheet><link href=css/chrome.css rel=stylesheet><link href=FontAwesome/css/font-awesome.css rel=stylesheet><link href=fonts/fonts.css rel=stylesheet><link href=highlight.css rel=stylesheet><link href=tomorrow-night.css rel=stylesheet><link href=ayu-highlight.css rel=stylesheet><link href=style.css rel=stylesheet><body><script>var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";</script><script>try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }</script><script>var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');</script><script>var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);</script><nav aria-label="Table of contents"class=sidebar id=sidebar><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=cover.html>Cover</a><li class="chapter-item expanded affix"><a href=buy.html>Buy PDF/EPUB versions</a><li class="chapter-item expanded"><a href=preface.html><strong aria-hidden=true>1.</strong> Preface</a><li class="chapter-item expanded"><a href=introduction.html><strong aria-hidden=true>2.</strong> Introduction</a><li class="chapter-item expanded"><a class=active href=frequently-used-options.html><strong aria-hidden=true>3.</strong> Frequently used options</a><li class="chapter-item expanded"><a href=breere-regular-expressions.html><strong aria-hidden=true>4.</strong> BRE/ERE Regular Expressions</a><li class="chapter-item expanded"><a href=context-matching.html><strong aria-hidden=true>5.</strong> Context matching</a><li class="chapter-item expanded"><a href=recursive-search.html><strong aria-hidden=true>6.</strong> Recursive search</a><li class="chapter-item expanded"><a href=miscellaneous-options.html><strong aria-hidden=true>7.</strong> Miscellaneous options</a><li class="chapter-item expanded"><a href=perl-compatible-regular-expressions.html><strong aria-hidden=true>8.</strong> Perl Compatible Regular Expressions</a><li class="chapter-item expanded"><a href=gotchas-and-tricks.html><strong aria-hidden=true>9.</strong> Gotchas and Tricks</a><li class="chapter-item expanded"><a href=ripgrep.html><strong aria-hidden=true>10.</strong> ripgrep</a><li class="chapter-item expanded"><a href=further-reading.html><strong aria-hidden=true>11.</strong> Further Reading</a><li class="chapter-item expanded"><a href=Exercise_solutions.html><strong aria-hidden=true>12.</strong> Exercise Solutions</a></li><br><hr><li class="chapter-item expanded"><i class="fa fa-github"id=git-repository-button></i><a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep>   Source code</a><li class="chapter-item expanded"><i class="fa fa-home"id=home-button></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i class="fa fa-book"id=book-button></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i class="fa fa-envelope"id=mail-button></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a><li class="chapter-item expanded"><i class="fa fa-twitter"id=twitter-button></i><a href=https://twitter.com/learn_byexample>   Twitter</a></ol></div><div class=sidebar-resize-handle id=sidebar-resize-handle></div></nav><div class=page-wrapper id=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div class="menu-bar sticky bordered"id=menu-bar><div class=left-buttons><button aria-label="Toggle Table of Contents"title="Toggle Table of Contents"aria-controls=sidebar class=icon-button id=sidebar-toggle type=button><i class="fa fa-bars"></i></button><button aria-label="Change theme"title="Change theme"aria-controls=theme-list aria-expanded=false aria-haspopup=true class=icon-button id=theme-toggle type=button><i class="fa fa-paint-brush"></i></button><ul aria-label=Themes class=theme-popup id=theme-list role=menu><li role=none><button class=theme id=light role=menuitem>Light (default)</button><li role=none><button class=theme id=rust role=menuitem>Rust</button><li role=none><button class=theme id=coal role=menuitem>Coal</button><li role=none><button class=theme id=navy role=menuitem>Navy</button><li role=none><button class=theme id=ayu role=menuitem>Ayu</button></ul><button aria-label="Toggle Searchbar"title="Search. (Shortkey: s)"aria-controls=searchbar aria-expanded=false aria-keyshortcuts=S class=icon-button id=search-toggle type=button><i class="fa fa-search"></i></button></div><h1 class=menu-title>CLI text processing with GNU grep and ripgrep</h1><div class=right-buttons><a aria-label=Blog href=https://learnbyexample.github.io title=Blog> <i class="fa fa-home"id=home-button></i> </a><a aria-label=Twitter href=https://twitter.com/learn_byexample title=Twitter> <i class="fa fa-twitter"id=twitter-button></i> </a><a aria-label="Git repository"title="Git repository"href=https://github.com/learnbyexample/learn_gnugrep_ripgrep> <i class="fa fa-github"id=git-repository-button></i> </a></div></div><div class=hidden id=search-wrapper><form class=searchbar-outer id=searchbar-outer><input placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header id=searchbar name=searchbar type=search></form><div class="searchresults-outer hidden"id=searchresults-outer><div class=searchresults-header id=searchresults-header></div><ul id=searchresults></ul></div></div><script>document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });</script><div class=content id=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=frequently-used-options><a class=header href=#frequently-used-options>Frequently used options</a></h1><p>This chapter will cover many of the options provided by <code>GNU grep</code>. Regular expressions will be covered later, so the examples in this chapter will only use literal strings as search patterns. Literal (fixed string) matching refers to exact string comparison, so no special meaning is assigned for any of the search characters.<blockquote><p><img alt=info src=images/info.svg> The <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep/tree/master/example_files>example_files</a> directory has all the files used in the examples.</blockquote><h2 id=basic-string-search><a class=header href=#basic-string-search>Basic string search</a></h2><p>By default, <code>grep</code> will print all the input <em>lines</em> that match the given search patterns. The newline character <code>\n</code> is the line separator by default. This section will show you how to filter lines matching a given search string using <code>grep</code>. Consider this sample input file:<pre><code class=language-bash>$ cat ip.txt
it is a warm and cozy day
listen to what I say
go play in the park
come back before the sky turns dark

There are so many delights to cherish
Apple, Banana and Cherry
Bread, Butter and Jelly
Try them all before you perish
</code></pre><p>To filter desired lines, invoke the <code>grep</code> command, pass the search string and then specify one or more filenames that have to be searched. As a good practice, always use single quotes around the search string. Examples requiring shell interpretation will be discussed later.<pre><code class=language-bash>$ grep 'play' ip.txt
go play in the park

$ grep 'y t' ip.txt
come back before the sky turns dark
Try them all before you perish
</code></pre><p><code>grep</code> will perform the search on <code>stdin</code> data if there are no file arguments or if <code>-</code> is used as a filename.<pre><code class=language-bash>$ printf 'apple\nbanana\nmango\nfig\n' | grep 'an'
banana
mango

$ printf 'apple\nbanana\nmango\nfig\n' | grep 'an' -
banana
mango
</code></pre><p>Here's an example where <code>grep</code> reads user written <code>stdin</code> data and the filtered output is redirected to a file.<pre><code class=language-bash># press Ctrl+d after the line containing 'histogram'
$ grep 'is' > op.txt
hi there
this is a sample line
have a nice day
histogram

$ cat op.txt
this is a sample line
histogram

$ rm op.txt
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> If your input file has <code>\r\n</code> (carriage return and newline characters) as the line ending, convert the input file to Unix-style before processing. See <a href=https://stackoverflow.com/q/45772525/4082052>stackoverflow: Why does my tool output overwrite itself and how do I fix it?</a> for a detailed discussion and mitigation methods.<pre><code class=language-bash># Unix style
$ printf '42\n' | file -
/dev/stdin: ASCII text

# DOS style
$ printf '42\r\n' | file -
/dev/stdin: ASCII text, with CRLF line terminators
</code></pre></blockquote><h2 id=fixed-string-search><a class=header href=#fixed-string-search>Fixed string search</a></h2><p>The search string (pattern) is treated as a Basic Regular Expression (BRE) by default. But regular expressions is a topic for the next chapter. For now, use the <code>-F</code> option to indicate that the patterns should be matched literally.<pre><code class=language-bash># oops, why did it not match?
$ echo 'int a[5]' | grep 'a[5]'
# where did that error come from??
$ echo 'int a[5]' | grep 'a['
grep: Invalid regular expression
# what is going on???
$ echo 'int a[5]' | grep 'a[5'
grep: Unmatched [, [^, [:, [., or [=

# use the -F option to match strings literally
$ echo 'int a[5]' | grep -F 'a[5]'
int a[5]
</code></pre><blockquote><p><img alt=info src=images/info.svg> If the search string doesn't have any regular expression metacharacters, <code>GNU grep</code> will try a literal search even if the <code>-F</code> option isn't used.</blockquote><h2 id=case-insensitive-search><a class=header href=#case-insensitive-search>Case insensitive search</a></h2><p>Sometimes, you don't know if a log file contains case variable search terms, such as <code>error</code>, <code>Error</code>, or <code>ERROR</code>. In such cases, you can use the <code>-i</code> option to ignore case.<pre><code class=language-bash>$ grep -i 'the' ip.txt
go play in the park
come back before the sky turns dark
There are so many delights to cherish
Try them all before you perish

$ printf 'Cat\ncOnCaT\ncut\n' | grep -i 'cat'
Cat
cOnCaT
</code></pre><h2 id=invert-matching-lines><a class=header href=#invert-matching-lines>Invert matching lines</a></h2><p>Use the <code>-v</code> option to get lines other than those matching the search term.<pre><code class=language-bash>$ seq 4 | grep -v '3'
1
2
4

$ printf 'goal\nrate\neat\npit' | grep -v 'at'
goal
pit
</code></pre><blockquote><p><img alt=info src=images/info.svg> Text processing often involves negating a logic to arrive at a solution or to make it simpler. Look out for opposite pairs like <code>-l -L</code>, <code>-h -H</code>, negative logic in regular expressions and so on in the examples to follow.</blockquote><h2 id=line-number-and-count><a class=header href=#line-number-and-count>Line number and count</a></h2><p>The <code>-n</code> option will prefix line numbers to matching results, using a colon character as the separator. This is useful to quickly locate matching lines for further processing.<pre><code class=language-bash>$ grep -n 'to' ip.txt
2:listen to what I say
6:There are so many delights to cherish

$ printf 'great\nneat\nuser' | grep -n 'eat'
1:great
2:neat
</code></pre><p>Having to count the total number of matching lines comes up often. Somehow piping <code>grep</code> output to the <code>wc</code> command is prevalent instead of simply using the <code>-c</code> option.<pre><code class=language-bash># number of lines matching the pattern
$ grep -c 'is' ip.txt
4

# number of lines NOT matching the pattern
$ printf 'goal\nrate\neat\npit' | grep -vc 'g'
3
</code></pre><p>When multiple input files are passed, the count is displayed for each file separately. Use <code>cat</code> if you need a combined count.<pre><code class=language-bash># here - represents the stdin data
$ printf 'this\nis\ncool\n' | grep -c 'is' ip.txt -
ip.txt:4
(standard input):2

# useful application of the cat command
$ cat <(printf 'this\nis\ncool\n') ip.txt | grep -c 'is'
6
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> The output given by the <code>-c</code> option is the total number of <strong>lines</strong> matching the given patterns, not the total number of matches. Use the <code>-o</code> option, and pipe the output to <code>wc -l</code> to count every occurrence (example shown later).</blockquote><h2 id=limiting-output-lines><a class=header href=#limiting-output-lines>Limiting output lines</a></h2><p>Sometimes, there are too many results, in which case you could pipe the output to a <strong>pager</strong> tool like <code>less</code>. Or use the <code>-m</code> option to limit how many matching lines should be displayed for each input file. <code>grep</code> will stop processing an input file as soon as the condition specified by <code>-m</code> is satisfied. Note that just like the <code>-c</code> option, <code>-m</code> works by line count and not based on the total number of matches.<pre><code class=language-bash>$ grep -m2 'is' ip.txt
it is a warm and cozy day
listen to what I say

$ seq 1000 | grep -m4 '2'
2
12
20
21
</code></pre><h2 id=multiple-search-strings><a class=header href=#multiple-search-strings>Multiple search strings</a></h2><p>The <code>-e</code> option can be used to specify multiple search strings from the command line. This is similar to conditional OR boolean logic.<pre><code class=language-bash># search for 'what' or 'But'
$ grep -e 'what' -e 'But' ip.txt
listen to what I say
Bread, Butter and Jelly
</code></pre><p>If you have a huge list of strings to search, save them in a file, one search string per line. Make sure there are no empty lines. Then use the <code>-f</code> option to specify a file as the source of search strings. You can use this option multiple times and also add more patterns from the command line using the <code>-e</code> option. Also, add the <code>-F</code> option when searching for literal matches. It is easy to miss regular expression metacharacters in a big list of terms.<pre><code class=language-bash>$ cat search.txt
say
you

$ grep -Ff search.txt ip.txt
listen to what I say
Try them all before you perish

# example with both -f and -e options
$ grep -Ff search.txt -e 'it' -e 'are' ip.txt
it is a warm and cozy day
listen to what I say
There are so many delights to cherish
Try them all before you perish
</code></pre><p>To find lines matching more than one search term, you'd need to either resort to using regular expressions (covered later) or workaround by using shell pipes. This is similar to conditional AND boolean logic.<pre><code class=language-bash># match lines containing both 'is' and 'to' in any order
# same as: grep 'to' ip.txt | grep 'is'
$ grep 'is' ip.txt | grep 'to'
listen to what I say
There are so many delights to cherish
</code></pre><h2 id=get-filename-instead-of-matching-lines><a class=header href=#get-filename-instead-of-matching-lines>Get filename instead of matching lines</a></h2><p>Often, you just want a list of filenames that match the search patterns. The output might get saved for future reference or passed to another command like <code>sed</code>, <code>awk</code>, <code>perl</code>, <code>sort</code>, etc for further processing. Some of these commands can handle search by themselves, but <code>grep</code> is a fast and specialized tool for searching and using shell pipes can improve performance if parallel processing is available. Similar to the <code>-m</code> option, <code>grep</code> will stop processing the input file as soon as the given condition is satisfied.<ul><li><code>-l</code> will list files matching the pattern<li><code>-L</code> will list files NOT matching the pattern</ul><p>Here are some examples:<pre><code class=language-bash># list filename if it contains 'are'
$ grep -l 'are' ip.txt search.txt
ip.txt
# no output because no match was found
$ grep -l 'xyz' ip.txt search.txt
# list filename if it contains 'say'
$ grep -l 'say' ip.txt search.txt
ip.txt
search.txt

# list filename if it does NOT contain 'xyz'
$ grep -L 'xyz' ip.txt search.txt
ip.txt
search.txt
# list filename if it does NOT contain 'are'
$ grep -L 'are' ip.txt search.txt
search.txt
</code></pre><h2 id=filename-prefix-for-matching-lines><a class=header href=#filename-prefix-for-matching-lines>Filename prefix for matching lines</a></h2><p>If there are multiple input files, <code>grep</code> will automatically prefix the filename when displaying the matching lines. You can also control whether or not to add the prefix using the following options:<ul><li><code>-h</code> option will prevent filename prefix in the output (default for single input file)<li><code>-H</code> option will always show filename prefix (default for multiple input files)</ul><pre><code class=language-bash># -h is on by default for single input file
$ grep 'say' ip.txt
listen to what I say
# using -h to suppress filename prefix for multiple input files
$ printf 'say\nyou\n' | grep -h 'say' - ip.txt
say
listen to what I say

# -H is on by default for multiple input files
$ printf 'say\nyou\n' | grep 'say' - ip.txt
(standard input):say
ip.txt:listen to what I say
# use -H to always show filename prefix
# instead of -H, you can also provide /dev/null as an additional input file
$ grep -H 'say' ip.txt
ip.txt:listen to what I say
</code></pre><h2 id=quickfix><a class=header href=#quickfix>Quickfix</a></h2><p>The <code>vim</code> editor has a quickfix option <code>-q</code> that makes it easy to edit the matching lines from <code>grep</code>'s output. Make sure that the output has both line numbers and filename prefixes.<pre><code class=language-bash># -H ensures filename prefix and -n provides line numbers
$ grep -Hn 'say' ip.txt search.txt
ip.txt:2:listen to what I say
search.txt:1:say

# use :cn and :cp to navigate to next/previous occurrences
# command-line area at the bottom will show number of matches and filenames
# you can also save the grep output and pass that filename instead of <()
$ vim -q <(grep -Hn 'say' ip.txt search.txt)
</code></pre><h2 id=colored-output><a class=header href=#colored-output>Colored output</a></h2><p>When working from the terminal, having the <code>--color</code> option enabled makes it easier to spot the matching portions in the output. Especially useful when you are experimenting to find the correct regular expression. Modern terminals will usually have color support, see <a href=https://unix.stackexchange.com/q/9957/109046>unix.stackexchange: How to check if bash can print colors?</a> for details.<p>The <code>--color</code> (or <code>--colour</code>) option will highlight matching patterns, line numbers, filenames, etc. There are three different settings:<ul><li><code>auto</code> will result in color highlighting when results are displayed on terminal, but not when the output is redirected to another command, file, etc. This is the default setting<li><code>always</code> will result in color highlighting when results are displayed on terminal as well as when the output is redirected to another command, file, etc<li><code>never</code> explicitly disables color highlighting</ul><p>Here are couple of examples with the <code>--color</code> option enabled (default is <code>auto</code>).<p align=center><img alt="grep color output"src=./images/color_output.png><p>It is typical to alias both the <code>ls</code> and <code>grep</code> commands to include <code>--color=auto</code>.<pre><code class=language-bash># aliases are usually saved in ~/.bashrc or ~/.bash_aliases
$ alias ls='ls --color=auto'
$ alias grep='grep --color=auto'
</code></pre><p>Using <code>--color=always</code> is handy if you want to retain color information even when the output is redirected. For example, piping the results to the <code>less</code> command.<pre><code class=language-bash>$ grep --color=always -i 'the' ip.txt | less -R
</code></pre><p>The below image will help you understand the difference between the <code>auto</code> and <code>always</code> features. In the first case, <code>is</code> gets highlighted even after piping, while in the second case <code>is</code> loses the color information. In practice, <code>always</code> is rarely used as it provides extra information to matching lines, which could cause undesirable results when processed.<p align=center><img alt="grep auto vs always"src=./images/auto_vs_always.png><h2 id=match-whole-word><a class=header href=#match-whole-word>Match whole word</a></h2><p>A word character is any alphabet (irrespective of case), digit and the underscore character. You might wonder why there are digits and underscores as well, why not only alphabets? This comes from variable and function naming conventions — typically alphabets, digits and underscores are allowed. So, the definition is more programming oriented than natural language. The <code>-w</code> option will ensure that given patterns are not surrounded by other word characters. For example, this helps to distinguish <code>par</code> from <code>spar</code>, <code>park</code>, <code>apart</code>, <code>par2</code>, <code>_par</code>, etc.<pre><code class=language-bash># this matches 'par' anywhere in the line
$ printf 'par value\nheir apparent\n' | grep 'par'
par value
heir apparent
# this matches 'par' only as a whole word
$ printf 'par value\nheir apparent\n' | grep -w 'par'
par value
</code></pre><blockquote><p><img alt=warning src=images/warning.svg> The <code>-w</code> option behaves a bit differently than word boundaries in regular expressions. See the <a href=./gotchas-and-tricks.html#word-boundary-differences>Word boundary differences</a> section for details.</blockquote><h2 id=match-whole-line><a class=header href=#match-whole-line>Match whole line</a></h2><p>Another useful option is <code>-x</code>, which will display a line only if the entire line satisfies the given pattern.<pre><code class=language-bash># this matches 'my book' anywhere in the line
$ printf 'see my book list\nmy book\n' | grep 'my book'
see my book list
my book
# this matches 'my book' only as a whole line
$ printf 'see my book list\nmy book\n' | grep -x 'my book'
my book

$ grep 'say' ip.txt search.txt
ip.txt:listen to what I say
search.txt:say
$ grep -x 'say' ip.txt search.txt
search.txt:say

# count empty lines, won't work for files with DOS style line endings
$ grep -cx '' ip.txt
1
</code></pre><h2 id=comparing-lines-between-files><a class=header href=#comparing-lines-between-files>Comparing lines between files</a></h2><p>The <code>-f</code> and <code>-x</code> options can be combined to get common lines between two files or the difference when <code>-v</code> is used as well. If you want to match the lines literally, it is advised to use the <code>-F</code> option as well, because you might not know if there are regular expression metacharacters present in the input files or not.<pre><code class=language-bash>$ printf 'teal\nlight blue\nbrown\nyellow\n' > colors_1
$ printf 'blue\nblack\ndark green\nyellow\n' > colors_2

# common lines between two files
$ grep -Fxf colors_1 colors_2
yellow

# lines present in colors_2 but not in colors_1
$ grep -Fvxf colors_1 colors_2
blue
black
dark green

# lines present in colors_1 but not in colors_2
$ grep -Fvxf colors_2 colors_1
teal
light blue
brown
</code></pre><p>See also <a href=https://stackoverflow.com/q/42239179/4082052>stackoverflow: Fastest way to find lines of a text file from another larger text file</a> — go through all the answers.<h2 id=extract-only-matching-portion><a class=header href=#extract-only-matching-portion>Extract only matching portion</a></h2><p>If the total number of matches is required, use the <code>-o</code> option to display only the matching portions (one per line), and then use <code>wc</code> to count them. This option is more commonly used with regular expressions.<pre><code class=language-bash>$ grep -oi 'the' ip.txt
the
the
The
the

# -c only gives count of matching lines
$ grep -c 'an' ip.txt
4
# use -o to get each match on a separate line
$ grep -o 'an' ip.txt | wc -l
6
</code></pre><h2 id=summary><a class=header href=#summary>Summary</a></h2><p>In my initial years of CLI usage as a VLSI engineer, I knew only some of the options listed in this chapter. Didn't even know about the <code>--color</code> option. I've come across comments about not knowing the <code>-c</code> option in online forums. These are some of the reasons why I'd advise going through the list of all the options if you use a command frequently. Bonus points for maintaining a cheatsheet of example usage for future reference, passing on to your colleagues, etc.<h2 id=interactive-exercises><a class=header href=#interactive-exercises>Interactive exercises</a></h2><p>I wrote a TUI app to help you solve some of the exercises from this book interactively. See <a href=https://github.com/learnbyexample/TUI-apps/tree/main/GrepExercises>GrepExercises</a> repo for installation steps and <a href=https://github.com/learnbyexample/TUI-apps/blob/main/GrepExercises/app_guide.md>app_guide.md</a> for instructions on using this app.<p>Here's a sample screenshot:<p align=center><img alt="GrepExercises example"src=images/grep_exercises.png><h2 id=exercises><a class=header href=#exercises>Exercises</a></h2><blockquote><p><img alt=info src=images/info.svg> All the exercises are also collated together in one place at <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep/blob/master/exercises/Exercises.md>Exercises.md</a>. For solutions, see <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep/blob/master/exercises/Exercise_solutions.md>Exercise_solutions.md</a>.</blockquote><blockquote><p><img alt=info src=images/info.svg> The <a href=https://github.com/learnbyexample/learn_gnugrep_ripgrep/tree/master/exercises>exercises</a> directory has all the files used in this section.</blockquote><p><strong>1)</strong> Display lines containing <code>an</code> from the <code>sample.txt</code> input file.<pre><code class=language-bash>##### add your solution here
banana
mango
</code></pre><p><strong>2)</strong> Display lines containing <code>do</code> as a whole word from the <code>sample.txt</code> input file.<pre><code class=language-bash>##### add your solution here
Just do-it
</code></pre><p><strong>3)</strong> Display lines from <code>sample.txt</code> that satisfy both of these conditions:<ul><li><code>he</code> matched irrespective of case<li>either <code>World</code> or <code>Hi</code> matched case sensitively</ul><pre><code class=language-bash>##### add your solution here
Hello World
Hi there
</code></pre><p><strong>4)</strong> Display lines from <code>code.txt</code> containing <code>fruit[0]</code> literally.<pre><code class=language-bash>##### add your solution here
fruit[0] = 'apple'
</code></pre><p><strong>5)</strong> Display only the first two matching lines containing <code>t</code> from the <code>sample.txt</code> input file.<pre><code class=language-bash>##### add your solution here
Hi there
Just do-it
</code></pre><p><strong>6)</strong> Display only the first three matching lines that do <em>not</em> contain <code>he</code> from the <code>sample.txt</code> input file.<pre><code class=language-bash>##### add your solution here
Hello World

How are you
</code></pre><p><strong>7)</strong> Display lines from <code>sample.txt</code> that contain <code>do</code> along with line number prefix.<pre><code class=language-bash>##### add your solution here
6:Just do-it
13:Much ado about nothing
</code></pre><p><strong>8)</strong> For the input file <code>sample.txt</code>, count the number of times the string <code>he</code> is present, irrespective of case.<pre><code class=language-bash>##### add your solution here
5
</code></pre><p><strong>9)</strong> For the input file <code>sample.txt</code>, count the number of empty lines.<pre><code class=language-bash>##### add your solution here
4
</code></pre><p><strong>10)</strong> For the input files <code>sample.txt</code> and <code>code.txt</code>, display matching lines based on the search terms (one per line) present in the <code>terms.txt</code> file. Results should be prefixed with the corresponding input filename.<pre><code class=language-bash>$ cat terms.txt
are
not
go
fruit[0]

##### add your solution here
sample.txt:How are you
sample.txt:mango
sample.txt:Much ado about nothing
sample.txt:Adios amigo
code.txt:fruit[0] = 'apple'
</code></pre><p><strong>11)</strong> For the input file <code>sample.txt</code>, display lines containing <code>amigo</code> prefixed by the input filename as well as the line number.<pre><code class=language-bash>##### add your solution here
sample.txt:15:Adios amigo
</code></pre><p><strong>12)</strong> For the input files <code>sample.txt</code> and <code>code.txt</code>, display only the filename if it contains <code>apple</code>.<pre><code class=language-bash>##### add your solution here
code.txt
</code></pre><p><strong>13)</strong> For the input files <code>sample.txt</code> and <code>code.txt</code>, display only whole matching lines based on the search terms (one per line) present in the <code>lines.txt</code> file. Results should be prefixed with the corresponding input filename as well as the line number.<pre><code class=language-bash>$ cat lines.txt
banana
fruit = []

##### add your solution here
sample.txt:9:banana
code.txt:1:fruit = []
</code></pre><p><strong>14)</strong> For the input files <code>sample.txt</code> and <code>code.txt</code>, count the number of lines that do <em>not</em> match any of the search terms (one per line) present in the <code>terms.txt</code> file.<pre><code class=language-bash>##### add your solution here
sample.txt:11
code.txt:3
</code></pre><p><strong>15)</strong> Count the total number of lines containing <code>banana</code> in the input files <code>sample.txt</code> and <code>code.txt</code>.<pre><code class=language-bash>##### add your solution here
2
</code></pre><p><strong>16)</strong> Which two conditions are necessary for the output of the <code>grep</code> command to be suitable for the <code>vim -q</code> quickfix mode?<p><strong>17)</strong> What's the default setting for the <code>--color</code> option? Give an example where the <code>always</code> setting would be useful.<p><strong>18)</strong> The command shown below tries to get the number of empty lines, but apparently shows the wrong result, why?<pre><code class=language-bash>$ grep -cx '' dos.txt
0
</code></pre></main><nav aria-label="Page navigation"class=nav-wrapper><a aria-label="Previous chapter"class="mobile-nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=introduction.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="mobile-nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=breere-regular-expressions.html rel=next> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav aria-label="Page navigation"class=nav-wide-wrapper><a aria-label="Previous chapter"class="nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=introduction.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=breere-regular-expressions.html rel=next> <i class="fa fa-angle-right"></i> </a></nav></div><script>window.playground_copyable = true;</script><script charset=utf-8 src=elasticlunr.min.js></script><script charset=utf-8 src=mark.min.js></script><script charset=utf-8 src=searcher.js></script><script charset=utf-8 src=clipboard.min.js></script><script charset=utf-8 src=highlight.js></script><script charset=utf-8 src=book.js></script><script src=sidebar.js></script>